<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>HoTTEST Summer School 2022 Lecture Notes</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <article>

<pre class="Agda"><a id="9" class="Symbol">{-#</a> <a id="13" class="Keyword">OPTIONS</a> <a id="21" class="Pragma">--rewriting</a> <a id="33" class="Pragma">--without-K</a> <a id="45" class="Symbol">#-}</a>

<a id="50" class="Keyword">open</a> <a id="55" class="Keyword">import</a> <a id="62" href="new-prelude.html" class="Module">new-prelude</a>

<a id="75" class="Keyword">module</a> <a id="82" href="Lecture5-notes.html" class="Module">Lecture5-notes</a> <a id="97" class="Keyword">where</a>

<a id="104" class="Keyword">open</a> <a id="109" class="Keyword">import</a> <a id="116" href="Lecture4-notes.html" class="Module">Lecture4-notes</a> <a id="131" class="Keyword">hiding</a> <a id="138" class="Symbol">(</a><a id="139" href="Lecture4-notes.html#9118" data-type="S1 → Circle2" class="Function">to</a><a id="141" class="Symbol">;</a> <a id="143" href="Lecture4-notes.html#9389" data-type="Circle2 → S1" class="Function">from</a><a id="147" class="Symbol">;</a> <a id="149" href="Lecture4-notes.html#9552" data-type="to (from north) ≡ north" class="Function">from-to-north</a><a id="162" class="Symbol">;</a> <a id="164" href="Lecture4-notes.html#9616" data-type="to (from south) ≡ south" class="Function">from-to-south</a><a id="177" class="Symbol">;</a> <a id="179" href="Lecture4-notes.html#9678" data-type="(ap to (ap from west) ∙ from-to-south) ≡ west" class="Function">from-to-west</a><a id="191" class="Symbol">;</a> <a id="193" href="Lecture4-notes.html#9923" data-type="(ap to (ap from east) ∙ from-to-south) ≡ east" class="Function">from-to-east</a><a id="205" class="Symbol">;</a> <a id="207" href="Lecture4-notes.html#12720" data-type="(x y : A) → R x y → Path (A / R) (i x) (i y)" class="Postulate">q</a><a id="208" class="Symbol">)</a> <a id="210" class="Keyword">public</a>

</pre>
<h1 id="equivalences">Equivalences</h1>
<p>In this lecture, we will start proving some type equivalences, so we
need to code a definition of equivalence. In the Lecture 3 exercies, we
saw the definition of a bijection/isomorphism/quasi-equivalence in Agda:
a record consisting of maps back and forth with homotopies showing that
they compose to the identity. In the HoTT track, we saw the definition
of equivalence of types as a bi-invertible map. We can code this
similarly in Agda:</p>
<pre class="Agda"><a id="692" class="Keyword">record</a> <a id="is-equiv"></a><a id="699" href="Lecture5-notes.html#699" data-type="(f : A → B) → Set (l1 ⊔ l2)" class="Record">is-equiv</a> <a id="708" class="Symbol">{</a><a id="709" href="Lecture5-notes.html#709" class="Bound">l1</a> <a id="712" href="Lecture5-notes.html#712" class="Bound">l2</a> <a id="715" class="Symbol">:</a> <a id="717" href="Agda.Primitive.html#597" data-type="Set" class="Postulate">Level</a><a id="722" class="Symbol">}</a> <a id="724" class="Symbol">{</a><a id="725" href="Lecture5-notes.html#725" class="Bound">A</a> <a id="727" class="Symbol">:</a> <a id="729" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="734" href="Lecture5-notes.html#709" class="Bound">l1</a><a id="736" class="Symbol">}</a> <a id="738" class="Symbol">{</a><a id="739" href="Lecture5-notes.html#739" class="Bound">B</a> <a id="741" class="Symbol">:</a> <a id="743" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="748" href="Lecture5-notes.html#712" class="Bound">l2</a><a id="750" class="Symbol">}</a> <a id="752" class="Symbol">(</a><a id="753" href="Lecture5-notes.html#753" class="Bound">f</a> <a id="755" class="Symbol">:</a> <a id="757" href="Lecture5-notes.html#725" class="Bound">A</a> <a id="759" class="Symbol">→</a> <a id="761" href="Lecture5-notes.html#739" class="Bound">B</a><a id="762" class="Symbol">)</a> <a id="764" class="Symbol">:</a> <a id="766" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="771" class="Symbol">(</a><a id="772" href="Lecture5-notes.html#709" class="Bound">l1</a> <a id="775" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="777" href="Lecture5-notes.html#712" class="Bound">l2</a><a id="779" class="Symbol">)</a> <a id="781" class="Keyword">where</a>
  <a id="789" class="Keyword">constructor</a> <a id="Inverse"></a><a id="801" href="Lecture5-notes.html#801" data-type="(post-inverse : B → A) (is-post-inverse : (post-inverse ∘ f) ∼ id)
(pre-inverse : B → A) (is-pre-inverse : (f ∘ pre-inverse) ∼ id) →
is-equiv f" class="InductiveConstructor">Inverse</a>
  <a id="811" class="Keyword">field</a>
    <a id="is-equiv.post-inverse"></a><a id="821" href="Lecture5-notes.html#821" data-type="is-equiv f → B → A" class="Field">post-inverse</a>    <a id="837" class="Symbol">:</a> <a id="839" href="Lecture5-notes.html#739" class="Bound">B</a> <a id="841" class="Symbol">→</a> <a id="843" href="Lecture5-notes.html#725" class="Bound">A</a>
    <a id="is-equiv.is-post-inverse"></a><a id="849" href="Lecture5-notes.html#849" data-type="(r : is-equiv f) → (post-inverse r ∘ f) ∼ id" class="Field">is-post-inverse</a> <a id="865" class="Symbol">:</a> <a id="867" href="Lecture5-notes.html#821" data-type="is-equiv f → B → A" class="Field">post-inverse</a> <a id="880" href="new-prelude.html#2059" data-type="((y : B) → C y) → (f : A → B) (x : A) → C (f x)" class="Function Operator">∘</a> <a id="882" href="Lecture5-notes.html#753" class="Bound">f</a> <a id="884" href="new-prelude.html#1372" data-type="((x : A) → B x) → ((x : A) → B x) → Set (l1 ⊔ l2)" class="Function Operator">∼</a> <a id="886" href="new-prelude.html#2011" data-type="A → A" class="Function">id</a>
    <a id="is-equiv.pre-inverse"></a><a id="893" href="Lecture5-notes.html#893" data-type="is-equiv f → B → A" class="Field">pre-inverse</a>     <a id="909" class="Symbol">:</a> <a id="911" href="Lecture5-notes.html#739" class="Bound">B</a> <a id="913" class="Symbol">→</a> <a id="915" href="Lecture5-notes.html#725" class="Bound">A</a>
    <a id="is-equiv.is-pre-inverse"></a><a id="921" href="Lecture5-notes.html#921" data-type="(r : is-equiv f) → (f ∘ pre-inverse r) ∼ id" class="Field">is-pre-inverse</a>  <a id="937" class="Symbol">:</a> <a id="939" href="Lecture5-notes.html#753" class="Bound">f</a> <a id="941" href="new-prelude.html#2059" data-type="((y : B) → C y) → (f : A → B) (x : A) → C (f x)" class="Function Operator">∘</a> <a id="943" href="Lecture5-notes.html#893" data-type="is-equiv f → B → A" class="Field">pre-inverse</a> <a id="955" href="new-prelude.html#1372" data-type="((x : A) → B x) → ((x : A) → B x) → Set (l1 ⊔ l2)" class="Function Operator">∼</a> <a id="957" href="new-prelude.html#2011" data-type="A → A" class="Function">id</a>

<a id="961" class="Keyword">record</a> <a id="_≃_"></a><a id="968" href="Lecture5-notes.html#968" data-type="(A : Set l1) (B : Set l2) → Set (l1 ⊔ l2)" class="Record Operator">_≃_</a> <a id="972" class="Symbol">{</a><a id="973" href="Lecture5-notes.html#973" class="Bound">l1</a> <a id="976" href="Lecture5-notes.html#976" class="Bound">l2</a> <a id="979" class="Symbol">:</a> <a id="981" href="Agda.Primitive.html#597" data-type="Set" class="Postulate">Level</a><a id="986" class="Symbol">}</a> <a id="988" class="Symbol">(</a><a id="989" href="Lecture5-notes.html#989" class="Bound">A</a> <a id="991" class="Symbol">:</a> <a id="993" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="998" href="Lecture5-notes.html#973" class="Bound">l1</a><a id="1000" class="Symbol">)</a> <a id="1002" class="Symbol">(</a><a id="1003" href="Lecture5-notes.html#1003" class="Bound">B</a> <a id="1005" class="Symbol">:</a> <a id="1007" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="1012" href="Lecture5-notes.html#976" class="Bound">l2</a><a id="1014" class="Symbol">)</a> <a id="1016" class="Symbol">:</a> <a id="1018" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="1023" class="Symbol">(</a><a id="1024" href="Lecture5-notes.html#973" class="Bound">l1</a> <a id="1027" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="1029" href="Lecture5-notes.html#976" class="Bound">l2</a><a id="1031" class="Symbol">)</a> <a id="1033" class="Keyword">where</a>
  <a id="1041" class="Keyword">constructor</a>
    <a id="Equivalence"></a><a id="1057" href="Lecture5-notes.html#1057" data-type="(map : A → B) (is-equivalence : is-equiv map) → A ≃ B" class="InductiveConstructor">Equivalence</a>
  <a id="1071" class="Keyword">field</a>
    <a id="_≃_.map"></a><a id="1081" href="Lecture5-notes.html#1081" data-type="A ≃ B → A → B" class="Field">map</a> <a id="1085" class="Symbol">:</a> <a id="1087" href="Lecture5-notes.html#989" class="Bound">A</a> <a id="1089" class="Symbol">→</a> <a id="1091" href="Lecture5-notes.html#1003" class="Bound">B</a>
    <a id="_≃_.is-equivalence"></a><a id="1097" href="Lecture5-notes.html#1097" data-type="(r : A ≃ B) → is-equiv (map r)" class="Field">is-equivalence</a> <a id="1112" class="Symbol">:</a> <a id="1114" href="Lecture5-notes.html#699" data-type="(f : A → B) → Set (l1 ⊔ l2)" class="Record">is-equiv</a> <a id="1123" href="Lecture5-notes.html#1081" data-type="A ≃ B → A → B" class="Field">map</a>
</pre>
<p>Here are some short names for projecting the the forward and (one of
the) backward maps:</p>
<pre class="Agda"><a id="fwd"></a><a id="1230" href="Lecture5-notes.html#1230" data-type="A ≃ B → A → B" class="Function">fwd</a> <a id="1234" class="Symbol">:</a> <a id="1236" class="Symbol">∀</a> <a id="1238" class="Symbol">{</a><a id="1239" href="Lecture5-notes.html#1239" class="Bound">l1</a> <a id="1242" href="Lecture5-notes.html#1242" class="Bound">l2</a> <a id="1245" class="Symbol">:</a> <a id="1247" href="Agda.Primitive.html#597" data-type="Set" class="Postulate">Level</a><a id="1252" class="Symbol">}</a> <a id="1254" class="Symbol">{</a><a id="1255" href="Lecture5-notes.html#1255" class="Bound">A</a> <a id="1257" class="Symbol">:</a> <a id="1259" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="1264" href="Lecture5-notes.html#1239" class="Bound">l1</a><a id="1266" class="Symbol">}</a> <a id="1268" class="Symbol">{</a><a id="1269" href="Lecture5-notes.html#1269" class="Bound">B</a> <a id="1271" class="Symbol">:</a> <a id="1273" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="1278" href="Lecture5-notes.html#1242" class="Bound">l2</a><a id="1280" class="Symbol">}</a> <a id="1282" class="Symbol">→</a> <a id="1284" href="Lecture5-notes.html#1255" class="Bound">A</a> <a id="1286" href="Lecture5-notes.html#968" data-type="(A : Set l1) (B : Set l2) → Set (l1 ⊔ l2)" class="Record Operator">≃</a> <a id="1288" href="Lecture5-notes.html#1269" class="Bound">B</a> <a id="1290" class="Symbol">→</a> <a id="1292" href="Lecture5-notes.html#1255" class="Bound">A</a> <a id="1294" class="Symbol">→</a> <a id="1296" href="Lecture5-notes.html#1269" class="Bound">B</a>
<a id="1298" href="Lecture5-notes.html#1230" data-type="A ≃ B → A → B" class="Function">fwd</a> <a id="1302" href="Lecture5-notes.html#1302" class="Bound">e</a> <a id="1304" class="Symbol">=</a> <a id="1306" href="Lecture5-notes.html#1081" data-type="A ≃ B → A → B" class="Field">_≃_.map</a> <a id="1314" href="Lecture5-notes.html#1302" class="Bound">e</a>

<a id="bwd"></a><a id="1317" href="Lecture5-notes.html#1317" data-type="A ≃ B → B → A" class="Function">bwd</a> <a id="1321" class="Symbol">:</a> <a id="1323" class="Symbol">∀</a> <a id="1325" class="Symbol">{</a><a id="1326" href="Lecture5-notes.html#1326" class="Bound">l1</a> <a id="1329" href="Lecture5-notes.html#1329" class="Bound">l2</a> <a id="1332" class="Symbol">:</a> <a id="1334" href="Agda.Primitive.html#597" data-type="Set" class="Postulate">Level</a><a id="1339" class="Symbol">}</a> <a id="1341" class="Symbol">{</a><a id="1342" href="Lecture5-notes.html#1342" class="Bound">A</a> <a id="1344" class="Symbol">:</a> <a id="1346" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="1351" href="Lecture5-notes.html#1326" class="Bound">l1</a><a id="1353" class="Symbol">}</a> <a id="1355" class="Symbol">{</a><a id="1356" href="Lecture5-notes.html#1356" class="Bound">B</a> <a id="1358" class="Symbol">:</a> <a id="1360" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="1365" href="Lecture5-notes.html#1329" class="Bound">l2</a><a id="1367" class="Symbol">}</a> <a id="1369" class="Symbol">→</a> <a id="1371" href="Lecture5-notes.html#1342" class="Bound">A</a> <a id="1373" href="Lecture5-notes.html#968" data-type="(A : Set l1) (B : Set l2) → Set (l1 ⊔ l2)" class="Record Operator">≃</a> <a id="1375" href="Lecture5-notes.html#1356" class="Bound">B</a> <a id="1377" class="Symbol">→</a> <a id="1379" href="Lecture5-notes.html#1356" class="Bound">B</a> <a id="1381" class="Symbol">→</a> <a id="1383" href="Lecture5-notes.html#1342" class="Bound">A</a>
<a id="1385" href="Lecture5-notes.html#1317" data-type="A ≃ B → B → A" class="Function">bwd</a> <a id="1389" href="Lecture5-notes.html#1389" class="Bound">e</a> <a id="1391" class="Symbol">=</a> <a id="1393" href="Lecture5-notes.html#821" data-type="is-equiv f → B → A" class="Field">is-equiv.post-inverse</a> <a id="1415" class="Symbol">(</a><a id="1416" href="Lecture5-notes.html#1097" data-type="(r : A ≃ B) → is-equiv (map r)" class="Field">_≃_.is-equivalence</a> <a id="1435" href="Lecture5-notes.html#1389" class="Bound">e</a><a id="1436" class="Symbol">)</a>
</pre>
<p>An isomorphism can be improved to an equivalence by using the same
function as the pre-inverse and post-inverse:</p>
<pre class="Agda"><a id="improve"></a><a id="1565" href="Lecture5-notes.html#1565" data-type="A ≅ B → A ≃ B" class="Function">improve</a> <a id="1573" class="Symbol">:</a> <a id="1575" class="Symbol">∀</a> <a id="1577" class="Symbol">{</a><a id="1578" href="Lecture5-notes.html#1578" class="Bound">l1</a> <a id="1581" href="Lecture5-notes.html#1581" class="Bound">l2</a> <a id="1584" class="Symbol">:</a> <a id="1586" href="Agda.Primitive.html#597" data-type="Set" class="Postulate">Level</a><a id="1591" class="Symbol">}</a> <a id="1593" class="Symbol">{</a><a id="1594" href="Lecture5-notes.html#1594" class="Bound">A</a> <a id="1596" class="Symbol">:</a> <a id="1598" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="1603" href="Lecture5-notes.html#1578" class="Bound">l1</a><a id="1605" class="Symbol">}</a> <a id="1607" class="Symbol">{</a><a id="1608" href="Lecture5-notes.html#1608" class="Bound">B</a> <a id="1610" class="Symbol">:</a> <a id="1612" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="1617" href="Lecture5-notes.html#1581" class="Bound">l2</a><a id="1619" class="Symbol">}</a> <a id="1621" class="Symbol">→</a> <a id="1623" href="Lecture5-notes.html#1594" class="Bound">A</a> <a id="1625" href="new-prelude.html#2864" data-type="(A : Set l1) (B : Set l2) → Set (l1 ⊔ l2)" class="Record Operator">≅</a> <a id="1627" href="Lecture5-notes.html#1608" class="Bound">B</a> <a id="1629" class="Symbol">→</a> <a id="1631" href="Lecture5-notes.html#1594" class="Bound">A</a> <a id="1633" href="Lecture5-notes.html#968" data-type="(A : Set l1) (B : Set l2) → Set (l1 ⊔ l2)" class="Record Operator">≃</a> <a id="1635" href="Lecture5-notes.html#1608" class="Bound">B</a>
<a id="1637" href="Lecture5-notes.html#1565" data-type="A ≅ B → A ≃ B" class="Function">improve</a> <a id="1645" class="Symbol">(</a><a id="1646" href="new-prelude.html#2950" data-type="(bijection : A → B) (bijectivity : is-bijection bijection) → A ≅ B" class="InductiveConstructor">Isomorphism</a> <a id="1658" href="Lecture5-notes.html#1658" class="Bound">f</a> <a id="1660" class="Symbol">(</a><a id="1661" href="new-prelude.html#2765" data-type="(inverse : B → A) (η : (inverse ∘ f) ∼ id)
(ε : (f ∘ inverse) ∼ id) →
is-bijection f" class="InductiveConstructor">Inverse</a> <a id="1669" href="Lecture5-notes.html#1669" class="Bound">g</a> <a id="1671" href="Lecture5-notes.html#1671" class="Bound">gf</a> <a id="1674" href="Lecture5-notes.html#1674" class="Bound">fg</a><a id="1676" class="Symbol">))</a> <a id="1679" class="Symbol">=</a> <a id="1681" href="Lecture5-notes.html#1057" data-type="(map : A → B) (is-equivalence : is-equiv map) → A ≃ B" class="InductiveConstructor">Equivalence</a> <a id="1693" href="Lecture5-notes.html#1658" class="Bound">f</a> <a id="1695" class="Symbol">(</a><a id="1696" href="Lecture5-notes.html#801" data-type="(post-inverse : B → A) (is-post-inverse : (post-inverse ∘ f) ∼ id)
(pre-inverse : B → A) (is-pre-inverse : (f ∘ pre-inverse) ∼ id) →
is-equiv f" class="InductiveConstructor">Inverse</a> <a id="1704" href="Lecture5-notes.html#1669" class="Bound">g</a> <a id="1706" href="Lecture5-notes.html#1671" class="Bound">gf</a> <a id="1709" href="Lecture5-notes.html#1669" class="Bound">g</a> <a id="1711" href="Lecture5-notes.html#1674" class="Bound">fg</a><a id="1713" class="Symbol">)</a>

</pre>
<h1 id="path-over-a-path">Path over a path</h1>
<p>Next, we will work towards stating the dependent elimination rules /
induction principles for HITs. To do this, we will need the notion of a
“dependent path” or “path over a path”.</p>
<p>Suppose you have a type A with elements a1 and a2 and a type family B
: A → Type with elements b1 : B a1 and b2 : B a2. It doesn’t type check
to ask if b1 ≡ b2 because b1 and b2 have different types. But if we also
have a path p : a1 ≡ a2 then we can ask whether b1 ≡ b2 “up to” that
path.</p>
<p>Using topological terminology, we can think about the <em>total
space</em> of B, type Σ x ∶ A , B, which has a map pr₁ : (Σ x ∶ A , B) →
A. When b : B x, we say that b is “in the fiber over x”, because the
element (x , b) : (Σ x ∶ A , B) projects to x by pr₁. One way to compare
elements in different fibres is to ask for a path in the total space,
i.e. a path (a1 , b1) ≡ (a2 , b2) [ Σ x ∶ A , B ]. Using the
characterization of paths in Σ types from Lecture 3 as pairs of paths,
such a path has a first component path a1 ≡ a2 [ A ]. We are often
interested in paths in the total space whose first component is a
specified path p : a1 ≡ a2 [ A ]. This can be represented by a pair of a
path q : (a1 , b1) ≡ (a2 , b2) [ Σ x ∶ A , B ] with a path fst (from-Σ-≡
q) ≡ p [ a1 ≡ a2 ]. However, there are a couple of more direct ways to
represent this in type theory.</p>
<p>The first way to represent a path over p is with a new inductive
definition:</p>
<pre class="Agda"><a id="3164" class="Keyword">data</a> <a id="PathOver"></a><a id="3169" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">PathOver</a> <a id="3178" class="Symbol">{</a><a id="3179" href="Lecture5-notes.html#3179" class="Bound">l1</a> <a id="3182" href="Lecture5-notes.html#3182" class="Bound">l2</a> <a id="3185" class="Symbol">:</a> <a id="3187" href="Agda.Primitive.html#597" data-type="Set" class="Postulate">Level</a><a id="3192" class="Symbol">}</a> <a id="3194" class="Symbol">{</a><a id="3195" href="Lecture5-notes.html#3195" class="Bound">A</a> <a id="3197" class="Symbol">:</a> <a id="3199" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="3204" href="Lecture5-notes.html#3179" class="Bound">l1</a><a id="3206" class="Symbol">}</a> <a id="3208" class="Symbol">(</a><a id="3209" href="Lecture5-notes.html#3209" class="Bound">B</a> <a id="3211" class="Symbol">:</a> <a id="3213" href="Lecture5-notes.html#3195" class="Bound">A</a> <a id="3215" class="Symbol">→</a> <a id="3217" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="3222" href="Lecture5-notes.html#3182" class="Bound">l2</a><a id="3224" class="Symbol">)</a> <a id="3226" class="Symbol">:</a>
              <a id="3242" class="Symbol">{</a><a id="3243" href="Lecture5-notes.html#3243" class="Bound">a1</a> <a id="3246" href="Lecture5-notes.html#3246" class="Bound">a2</a> <a id="3249" class="Symbol">:</a> <a id="3251" href="Lecture5-notes.html#3195" class="Bound">A</a><a id="3252" class="Symbol">}</a> <a id="3254" class="Symbol">(</a><a id="3255" href="Lecture5-notes.html#3255" class="Bound">p</a> <a id="3257" class="Symbol">:</a> <a id="3259" href="Lecture5-notes.html#3243" class="Bound">a1</a> <a id="3262" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="3264" href="Lecture5-notes.html#3246" class="Bound">a2</a><a id="3266" class="Symbol">)</a>
              <a id="3282" class="Symbol">(</a><a id="3283" href="Lecture5-notes.html#3283" class="Bound">b1</a> <a id="3286" class="Symbol">:</a> <a id="3288" href="Lecture5-notes.html#3209" class="Bound">B</a> <a id="3290" href="Lecture5-notes.html#3243" class="Bound">a1</a><a id="3292" class="Symbol">)</a> <a id="3294" class="Symbol">(</a><a id="3295" href="Lecture5-notes.html#3295" class="Bound">b2</a> <a id="3298" class="Symbol">:</a> <a id="3300" href="Lecture5-notes.html#3209" class="Bound">B</a> <a id="3302" href="Lecture5-notes.html#3246" class="Bound">a2</a><a id="3304" class="Symbol">)</a> <a id="3306" class="Symbol">→</a> <a id="3308" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="3313" class="Symbol">(</a><a id="3314" href="Lecture5-notes.html#3179" class="Bound">l1</a> <a id="3317" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="3319" href="Lecture5-notes.html#3182" class="Bound">l2</a><a id="3321" class="Symbol">)</a> <a id="3323" class="Keyword">where</a>
  <a id="PathOver.reflo"></a><a id="3331" href="Lecture5-notes.html#3331" data-type="PathOver B (refl x) y y" class="InductiveConstructor">reflo</a> <a id="3337" class="Symbol">:</a> <a id="3339" class="Symbol">{</a><a id="3340" href="Lecture5-notes.html#3340" class="Bound">x</a> <a id="3342" class="Symbol">:</a> <a id="3344" href="Lecture5-notes.html#3195" class="Bound">A</a><a id="3345" class="Symbol">}</a> <a id="3347" class="Symbol">{</a><a id="3348" href="Lecture5-notes.html#3348" class="Bound">y</a> <a id="3350" class="Symbol">:</a> <a id="3352" href="Lecture5-notes.html#3209" class="Bound">B</a> <a id="3354" href="Lecture5-notes.html#3340" class="Bound">x</a><a id="3355" class="Symbol">}</a> <a id="3357" class="Symbol">→</a> <a id="3359" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">PathOver</a> <a id="3368" href="Lecture5-notes.html#3209" class="Bound">B</a> <a id="3370" class="Symbol">(</a><a id="3371" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="3376" href="Lecture5-notes.html#3340" class="Bound">x</a><a id="3377" class="Symbol">)</a> <a id="3379" href="Lecture5-notes.html#3348" class="Bound">y</a> <a id="3381" href="Lecture5-notes.html#3348" class="Bound">y</a> 

<a id="3385" class="Keyword">syntax</a> <a id="3392" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">PathOver</a> <a id="3401" class="Bound">B</a> <a id="3403" class="Bound">p</a> <a id="3405" class="Bound">b1</a> <a id="3408" class="Bound">b2</a> <a id="3411" class="Symbol">=</a> <a id="3413" class="Bound">b1</a> <a id="3416" class="Datatype">≡</a> <a id="3418" class="Bound">b2</a> <a id="3421" class="Datatype">[</a> <a id="3423" class="Bound">B</a> <a id="3425" class="Datatype">↓</a> <a id="3427" class="Bound">p</a> <a id="3429" class="Datatype">]</a>
</pre>
<dl>
<dt>This is an “inductive family” with one constructor that says that
any y</dt>
<dd>
B x is equal to itself over reflexivity.
</dd>
</dl>
<p>Another way to represent a path over p is as a homogeneous path
transport B p b1 ≡ b2 [ B a2 ]. Semantically, this is because dependent
types are fibrations, which includes that any path-over b1 ≡ b2 [ B ↓ p]
factors uniquely into a heterogeneous path b1 ≡ transport B p b1 [ B ↓ p
] composed with a homogeneous path transport B p b1 ≡ b2 [ B a2 ].</p>
<p>In type theory, we can prove that these are equivalent by path
induction:</p>
<pre class="Agda"><a id="transport-to-pathover"></a><a id="3985" href="Lecture5-notes.html#3985" data-type="(B : A → Set l2) (p : a1 ≡ a2) (b1 : B a1) (b2 : B a2) →
(transport B p b1 ≡ b2) ≃ PathOver B p b1 b2" class="Function">transport-to-pathover</a> <a id="4007" class="Symbol">:</a> <a id="4009" class="Symbol">{</a><a id="4010" href="Lecture5-notes.html#4010" class="Bound">l1</a> <a id="4013" href="Lecture5-notes.html#4013" class="Bound">l2</a> <a id="4016" class="Symbol">:</a> <a id="4018" href="Agda.Primitive.html#597" data-type="Set" class="Postulate">Level</a><a id="4023" class="Symbol">}</a> <a id="4025" class="Symbol">{</a><a id="4026" href="Lecture5-notes.html#4026" class="Bound">A</a> <a id="4028" class="Symbol">:</a> <a id="4030" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="4035" href="Lecture5-notes.html#4010" class="Bound">l1</a><a id="4037" class="Symbol">}</a> <a id="4039" class="Symbol">(</a><a id="4040" href="Lecture5-notes.html#4040" class="Bound">B</a> <a id="4042" class="Symbol">:</a> <a id="4044" href="Lecture5-notes.html#4026" class="Bound">A</a> <a id="4046" class="Symbol">→</a> <a id="4048" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="4053" href="Lecture5-notes.html#4013" class="Bound">l2</a><a id="4055" class="Symbol">)</a>
                        <a id="4081" class="Symbol">{</a><a id="4082" href="Lecture5-notes.html#4082" class="Bound">a1</a> <a id="4085" href="Lecture5-notes.html#4085" class="Bound">a2</a> <a id="4088" class="Symbol">:</a> <a id="4090" href="Lecture5-notes.html#4026" class="Bound">A</a><a id="4091" class="Symbol">}</a> <a id="4093" class="Symbol">(</a><a id="4094" href="Lecture5-notes.html#4094" class="Bound">p</a> <a id="4096" class="Symbol">:</a> <a id="4098" href="Lecture5-notes.html#4082" class="Bound">a1</a> <a id="4101" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="4103" href="Lecture5-notes.html#4085" class="Bound">a2</a><a id="4105" class="Symbol">)</a>
                        <a id="4131" class="Symbol">(</a><a id="4132" href="Lecture5-notes.html#4132" class="Bound">b1</a> <a id="4135" class="Symbol">:</a> <a id="4137" href="Lecture5-notes.html#4040" class="Bound">B</a> <a id="4139" href="Lecture5-notes.html#4082" class="Bound">a1</a><a id="4141" class="Symbol">)</a> <a id="4143" class="Symbol">(</a><a id="4144" href="Lecture5-notes.html#4144" class="Bound">b2</a> <a id="4147" class="Symbol">:</a> <a id="4149" href="Lecture5-notes.html#4040" class="Bound">B</a> <a id="4151" href="Lecture5-notes.html#4085" class="Bound">a2</a><a id="4153" class="Symbol">)</a>
                     <a id="4176" class="Symbol">→</a> <a id="4178" class="Symbol">(</a><a id="4179" href="new-prelude.html#1241" data-type="(A : X → Set l2) → x ≡ y → A x → A y" class="Function">transport</a> <a id="4189" href="Lecture5-notes.html#4040" class="Bound">B</a> <a id="4191" href="Lecture5-notes.html#4094" class="Bound">p</a> <a id="4193" href="Lecture5-notes.html#4132" class="Bound">b1</a> <a id="4196" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="4198" href="Lecture5-notes.html#4144" class="Bound">b2</a><a id="4200" class="Symbol">)</a> <a id="4202" href="Lecture5-notes.html#968" data-type="(A : Set l1) (B : Set l2) → Set (l1 ⊔ l2)" class="Record Operator">≃</a> <a id="4204" class="Symbol">(</a><a id="4205" href="Lecture5-notes.html#4132" class="Bound">b1</a> <a id="4208" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">≡</a> <a id="4210" href="Lecture5-notes.html#4144" class="Bound">b2</a> <a id="4213" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">[</a> <a id="4215" href="Lecture5-notes.html#4040" class="Bound">B</a> <a id="4217" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">↓</a> <a id="4219" href="Lecture5-notes.html#4094" class="Bound">p</a> <a id="4221" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">]</a><a id="4222" class="Symbol">)</a> 
<a id="4225" href="Lecture5-notes.html#3985" data-type="(B : A → Set l2) (p : a1 ≡ a2) (b1 : B a1) (b2 : B a2) →
(transport B p b1 ≡ b2) ≃ PathOver B p b1 b2" class="Function">transport-to-pathover</a> <a id="4247" href="Lecture5-notes.html#4247" class="Bound">B</a> <a id="4249" class="Symbol">(</a><a id="4250" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="4255" class="Symbol">_)</a> <a id="4258" href="Lecture5-notes.html#4258" class="Bound">b1</a> <a id="4261" href="Lecture5-notes.html#4261" class="Bound">b2</a> <a id="4264" class="Symbol">=</a> <a id="4266" href="Lecture5-notes.html#1565" data-type="A ≅ B → A ≃ B" class="Function">improve</a> <a id="4274" class="Symbol">(</a><a id="4275" href="new-prelude.html#2950" data-type="(bijection : A → B) (bijectivity : is-bijection bijection) → A ≅ B" class="InductiveConstructor">Isomorphism</a> <a id="4287" class="Symbol">((λ</a> <a id="4291" class="Symbol">{</a> <a id="4293" class="Symbol">(</a><a id="4294" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="4299" class="Symbol">_)</a> <a id="4302" class="Symbol">→</a> <a id="4304" href="Lecture5-notes.html#3331" data-type="PathOver B (refl x) y y" class="InductiveConstructor">reflo</a> <a id="4310" class="Symbol">}))</a>
                                                       <a id="4369" class="Symbol">(</a><a id="4370" href="new-prelude.html#2765" data-type="(inverse : B → A) (η : (inverse ∘ f) ∼ id)
(ε : (f ∘ inverse) ∼ id) →
is-bijection f" class="InductiveConstructor">Inverse</a> <a id="4378" class="Symbol">(\</a> <a id="4381" class="Symbol">{</a> <a id="4383" href="Lecture5-notes.html#3331" data-type="PathOver B (refl x) y y" class="InductiveConstructor">reflo</a> <a id="4389" class="Symbol">→</a> <a id="4391" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="4396" class="Symbol">_})</a>
                                                                <a id="4464" class="Symbol">(\</a> <a id="4467" class="Symbol">{(</a><a id="4469" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="4474" class="Symbol">_)</a> <a id="4477" class="Symbol">→</a> <a id="4479" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="4484" class="Symbol">_})</a>
                                                                <a id="4552" class="Symbol">(\</a> <a id="4555" class="Symbol">{(</a><a id="4557" href="Lecture5-notes.html#3331" data-type="PathOver B (refl x) y y" class="InductiveConstructor">reflo</a><a id="4562" class="Symbol">)</a> <a id="4564" class="Symbol">→</a> <a id="4566" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="4571" class="Symbol">_})))</a>

<a id="path-to-pathover"></a><a id="4578" href="Lecture5-notes.html#4578" data-type="x ≡ y → PathOver B (refl a) x y" class="Function">path-to-pathover</a> <a id="4595" class="Symbol">:</a> <a id="4597" class="Symbol">∀</a> <a id="4599" class="Symbol">{</a><a id="4600" href="Lecture5-notes.html#4600" class="Bound">A</a> <a id="4602" class="Symbol">:</a> <a id="4604" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="4608" class="Symbol">}</a> <a id="4610" class="Symbol">{</a><a id="4611" href="Lecture5-notes.html#4611" class="Bound">B</a> <a id="4613" class="Symbol">:</a> <a id="4615" href="Lecture5-notes.html#4600" class="Bound">A</a> <a id="4617" class="Symbol">→</a> <a id="4619" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="4623" class="Symbol">}</a>
                 <a id="4642" class="Symbol">→</a> <a id="4644" class="Symbol">{</a><a id="4645" href="Lecture5-notes.html#4645" class="Bound">a</a> <a id="4647" class="Symbol">:</a> <a id="4649" href="Lecture5-notes.html#4600" class="Bound">A</a><a id="4650" class="Symbol">}</a> <a id="4652" class="Symbol">{</a><a id="4653" href="Lecture5-notes.html#4653" class="Bound">x</a> <a id="4655" href="Lecture5-notes.html#4655" class="Bound">y</a> <a id="4657" class="Symbol">:</a> <a id="4659" href="Lecture5-notes.html#4611" class="Bound">B</a> <a id="4661" href="Lecture5-notes.html#4645" class="Bound">a</a><a id="4662" class="Symbol">}</a>
                 <a id="4681" class="Symbol">→</a> <a id="4683" class="Symbol">(</a><a id="4684" href="Lecture5-notes.html#4684" class="Bound">p</a> <a id="4686" class="Symbol">:</a> <a id="4688" href="Lecture5-notes.html#4653" class="Bound">x</a> <a id="4690" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="4692" href="Lecture5-notes.html#4655" class="Bound">y</a><a id="4693" class="Symbol">)</a>
                 <a id="4712" class="Symbol">→</a> <a id="4714" href="Lecture5-notes.html#4653" class="Bound">x</a> <a id="4716" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">≡</a> <a id="4718" href="Lecture5-notes.html#4655" class="Bound">y</a> <a id="4720" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">[</a> <a id="4722" href="Lecture5-notes.html#4611" class="Bound">B</a> <a id="4724" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">↓</a> <a id="4726" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="4731" href="Lecture5-notes.html#4645" class="Bound">a</a> <a id="4733" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">]</a>
<a id="4735" href="Lecture5-notes.html#4578" data-type="x ≡ y → PathOver B (refl a) x y" class="Function">path-to-pathover</a> <a id="4752" href="Lecture5-notes.html#4752" class="Bound">p</a> <a id="4754" class="Symbol">=</a> <a id="4756" href="Lecture5-notes.html#1230" data-type="A ≃ B → A → B" class="Function">fwd</a> <a id="4760" class="Symbol">(</a><a id="4761" href="Lecture5-notes.html#3985" data-type="(B : A → Set l2) (p : a1 ≡ a2) (b1 : B a1) (b2 : B a2) →
(transport B p b1 ≡ b2) ≃ PathOver B p b1 b2" class="Function">transport-to-pathover</a> <a id="4783" class="Symbol">_</a> <a id="4785" class="Symbol">(</a><a id="4786" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="4791" class="Symbol">_)</a> <a id="4794" class="Symbol">_</a> <a id="4796" class="Symbol">_)</a> <a id="4799" href="Lecture5-notes.html#4752" class="Bound">p</a>
</pre>
ap of a dependent function naturally creates a path-over:
<pre class="Agda"><a id="apd"></a><a id="4872" href="Lecture5-notes.html#4872" data-type="(f : (x : A) → B x) (p : a1 ≡ a2) → PathOver B p (f a1) (f a2)" class="Function">apd</a> <a id="4876" class="Symbol">:</a> <a id="4878" class="Symbol">{</a><a id="4879" href="Lecture5-notes.html#4879" class="Bound">l1</a> <a id="4882" href="Lecture5-notes.html#4882" class="Bound">l2</a> <a id="4885" class="Symbol">:</a> <a id="4887" href="Agda.Primitive.html#597" data-type="Set" class="Postulate">Level</a><a id="4892" class="Symbol">}</a> <a id="4894" class="Symbol">{</a><a id="4895" href="Lecture5-notes.html#4895" class="Bound">A</a> <a id="4897" class="Symbol">:</a> <a id="4899" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="4904" href="Lecture5-notes.html#4879" class="Bound">l1</a><a id="4906" class="Symbol">}</a> <a id="4908" class="Symbol">{</a><a id="4909" href="Lecture5-notes.html#4909" class="Bound">B</a> <a id="4911" class="Symbol">:</a> <a id="4913" href="Lecture5-notes.html#4895" class="Bound">A</a> <a id="4915" class="Symbol">→</a> <a id="4917" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="4922" href="Lecture5-notes.html#4882" class="Bound">l2</a><a id="4924" class="Symbol">}</a>
      <a id="4932" class="Symbol">(</a><a id="4933" href="Lecture5-notes.html#4933" class="Bound">f</a> <a id="4935" class="Symbol">:</a> <a id="4937" class="Symbol">(</a><a id="4938" href="Lecture5-notes.html#4938" class="Bound">x</a> <a id="4940" class="Symbol">:</a> <a id="4942" href="Lecture5-notes.html#4895" class="Bound">A</a><a id="4943" class="Symbol">)</a> <a id="4945" class="Symbol">→</a> <a id="4947" href="Lecture5-notes.html#4909" class="Bound">B</a> <a id="4949" href="Lecture5-notes.html#4938" class="Bound">x</a><a id="4950" class="Symbol">)</a> <a id="4952" class="Symbol">{</a><a id="4953" href="Lecture5-notes.html#4953" class="Bound">a1</a> <a id="4956" href="Lecture5-notes.html#4956" class="Bound">a2</a> <a id="4959" class="Symbol">:</a> <a id="4961" href="Lecture5-notes.html#4895" class="Bound">A</a><a id="4962" class="Symbol">}</a> <a id="4964" class="Symbol">(</a><a id="4965" href="Lecture5-notes.html#4965" class="Bound">p</a> <a id="4967" class="Symbol">:</a> <a id="4969" href="Lecture5-notes.html#4953" class="Bound">a1</a> <a id="4972" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="4974" href="Lecture5-notes.html#4956" class="Bound">a2</a><a id="4976" class="Symbol">)</a>
    <a id="4982" class="Symbol">→</a> <a id="4984" href="Lecture5-notes.html#4933" class="Bound">f</a> <a id="4986" href="Lecture5-notes.html#4953" class="Bound">a1</a> <a id="4989" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">≡</a> <a id="4991" href="Lecture5-notes.html#4933" class="Bound">f</a> <a id="4993" href="Lecture5-notes.html#4956" class="Bound">a2</a> <a id="4996" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">[</a> <a id="4998" href="Lecture5-notes.html#4909" class="Bound">B</a> <a id="5000" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">↓</a> <a id="5002" href="Lecture5-notes.html#4965" class="Bound">p</a> <a id="5004" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">]</a>
<a id="5006" href="Lecture5-notes.html#4872" data-type="(f : (x : A) → B x) (p : a1 ≡ a2) → PathOver B p (f a1) (f a2)" class="Function">apd</a> <a id="5010" href="Lecture5-notes.html#5010" class="Bound">f</a> <a id="5012" class="Symbol">(</a><a id="5013" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="5018" class="Symbol">_)</a> <a id="5021" class="Symbol">=</a> <a id="5023" href="Lecture5-notes.html#3331" data-type="PathOver B (refl x) y y" class="InductiveConstructor">reflo</a>
</pre>
<p>We’ll use the inductive family definition mainly because it will be
closer to what you’ll see in Lectures 7,8,9 on Cubical Agda.</p>
<h1 id="dependent-elimsinduction-for-hits">Dependent elims/induction for
HITs</h1>
<p>We’re finally in a position to state the dependent elimination rules
for HITs. Let’s start with Circle2 because it’s a little easier to see
what’s going on.</p>
<pre class="Agda"><a id="5369" class="Keyword">postulate</a>
  <a id="Circle2-elim"></a><a id="5381" href="Lecture5-notes.html#5381" data-type="(X : Circle2 → Set) (n : X north) (s : X south) →
PathOver X west n s → PathOver X east n s → (x : Circle2) → X x" class="Postulate">Circle2-elim</a> <a id="5394" class="Symbol">:</a> <a id="5396" class="Symbol">(</a><a id="5397" href="Lecture5-notes.html#5397" class="Bound">X</a> <a id="5399" class="Symbol">:</a> <a id="5401" href="Lecture4-notes.html#7873" data-type="Set" class="Postulate">Circle2</a> <a id="5409" class="Symbol">→</a> <a id="5411" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="5415" class="Symbol">)</a>
                 <a id="5434" class="Symbol">(</a><a id="5435" href="Lecture5-notes.html#5435" class="Bound">n</a> <a id="5437" class="Symbol">:</a> <a id="5439" href="Lecture5-notes.html#5397" class="Bound">X</a> <a id="5441" href="Lecture4-notes.html#7890" data-type="Circle2" class="Postulate">north</a><a id="5446" class="Symbol">)</a>
                 <a id="5465" class="Symbol">(</a><a id="5466" href="Lecture5-notes.html#5466" class="Bound">s</a> <a id="5468" class="Symbol">:</a> <a id="5470" href="Lecture5-notes.html#5397" class="Bound">X</a> <a id="5472" href="Lecture4-notes.html#7908" data-type="Circle2" class="Postulate">south</a><a id="5477" class="Symbol">)</a>
                 <a id="5496" class="Symbol">(</a><a id="5497" href="Lecture5-notes.html#5497" class="Bound">w</a> <a id="5499" class="Symbol">:</a> <a id="5501" href="Lecture5-notes.html#5435" class="Bound">n</a> <a id="5503" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">≡</a> <a id="5505" href="Lecture5-notes.html#5466" class="Bound">s</a> <a id="5507" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">[</a> <a id="5509" href="Lecture5-notes.html#5397" class="Bound">X</a> <a id="5511" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">↓</a> <a id="5513" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a> <a id="5518" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">]</a><a id="5519" class="Symbol">)</a>
                 <a id="5538" class="Symbol">(</a><a id="5539" href="Lecture5-notes.html#5539" class="Bound">e</a> <a id="5541" class="Symbol">:</a> <a id="5543" href="Lecture5-notes.html#5435" class="Bound">n</a> <a id="5545" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">≡</a> <a id="5547" href="Lecture5-notes.html#5466" class="Bound">s</a> <a id="5549" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">[</a> <a id="5551" href="Lecture5-notes.html#5397" class="Bound">X</a> <a id="5553" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">↓</a> <a id="5555" href="Lecture4-notes.html#7950" data-type="north ≡ south" class="Postulate">east</a> <a id="5560" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">]</a><a id="5561" class="Symbol">)</a>
               <a id="5578" class="Symbol">→</a> <a id="5580" class="Symbol">(</a><a id="5581" href="Lecture5-notes.html#5581" class="Bound">x</a> <a id="5583" class="Symbol">:</a> <a id="5585" href="Lecture4-notes.html#7873" data-type="Set" class="Postulate">Circle2</a><a id="5592" class="Symbol">)</a> <a id="5594" class="Symbol">→</a> <a id="5596" href="Lecture5-notes.html#5397" class="Bound">X</a> <a id="5598" href="Lecture5-notes.html#5581" class="Bound">x</a>
  <a id="Circle2-elim-north"></a><a id="5602" href="Lecture5-notes.html#5602" data-type="(X : Circle2 → Set) (n : X north) (s : X south)
(w : PathOver X west n s) (e : PathOver X east n s) →
Circle2-elim X n s w e north ≡ n" class="Postulate">Circle2-elim-north</a> <a id="5621" class="Symbol">:</a> <a id="5623" class="Symbol">(</a><a id="5624" href="Lecture5-notes.html#5624" class="Bound">X</a> <a id="5626" class="Symbol">:</a> <a id="5628" href="Lecture4-notes.html#7873" data-type="Set" class="Postulate">Circle2</a> <a id="5636" class="Symbol">→</a> <a id="5638" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="5642" class="Symbol">)</a> <a id="5644" class="Symbol">(</a><a id="5645" href="Lecture5-notes.html#5645" class="Bound">n</a> <a id="5647" class="Symbol">:</a> <a id="5649" href="Lecture5-notes.html#5624" class="Bound">X</a> <a id="5651" href="Lecture4-notes.html#7890" data-type="Circle2" class="Postulate">north</a><a id="5656" class="Symbol">)</a> <a id="5658" class="Symbol">(</a><a id="5659" href="Lecture5-notes.html#5659" class="Bound">s</a> <a id="5661" class="Symbol">:</a> <a id="5663" href="Lecture5-notes.html#5624" class="Bound">X</a> <a id="5665" href="Lecture4-notes.html#7908" data-type="Circle2" class="Postulate">south</a><a id="5670" class="Symbol">)</a>
                       <a id="5695" class="Symbol">(</a><a id="5696" href="Lecture5-notes.html#5696" class="Bound">w</a> <a id="5698" class="Symbol">:</a> <a id="5700" href="Lecture5-notes.html#5645" class="Bound">n</a> <a id="5702" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">≡</a> <a id="5704" href="Lecture5-notes.html#5659" class="Bound">s</a> <a id="5706" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">[</a> <a id="5708" href="Lecture5-notes.html#5624" class="Bound">X</a> <a id="5710" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">↓</a> <a id="5712" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a> <a id="5717" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">]</a><a id="5718" class="Symbol">)</a> <a id="5720" class="Symbol">(</a><a id="5721" href="Lecture5-notes.html#5721" class="Bound">e</a> <a id="5723" class="Symbol">:</a> <a id="5725" href="Lecture5-notes.html#5645" class="Bound">n</a> <a id="5727" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">≡</a> <a id="5729" href="Lecture5-notes.html#5659" class="Bound">s</a> <a id="5731" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">[</a> <a id="5733" href="Lecture5-notes.html#5624" class="Bound">X</a> <a id="5735" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">↓</a> <a id="5737" href="Lecture4-notes.html#7950" data-type="north ≡ south" class="Postulate">east</a> <a id="5742" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">]</a><a id="5743" class="Symbol">)</a>
                     <a id="5766" class="Symbol">→</a> <a id="5768" href="Lecture5-notes.html#5381" data-type="(X : Circle2 → Set) (n : X north) (s : X south) →
PathOver X west n s → PathOver X east n s → (x : Circle2) → X x" class="Postulate">Circle2-elim</a> <a id="5781" href="Lecture5-notes.html#5624" class="Bound">X</a> <a id="5783" href="Lecture5-notes.html#5645" class="Bound">n</a> <a id="5785" href="Lecture5-notes.html#5659" class="Bound">s</a> <a id="5787" href="Lecture5-notes.html#5696" class="Bound">w</a> <a id="5789" href="Lecture5-notes.html#5721" class="Bound">e</a> <a id="5791" href="Lecture4-notes.html#7890" data-type="Circle2" class="Postulate">north</a> <a id="5797" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="5799" href="Lecture5-notes.html#5645" class="Bound">n</a> 
  <a id="Circle2-elim-south"></a><a id="5804" href="Lecture5-notes.html#5804" data-type="(X : Circle2 → Set) (n : X north) (s : X south)
(w : PathOver X west n s) (e : PathOver X east n s) →
Circle2-elim X n s w e south ≡ s" class="Postulate">Circle2-elim-south</a> <a id="5823" class="Symbol">:</a> <a id="5825" class="Symbol">(</a><a id="5826" href="Lecture5-notes.html#5826" class="Bound">X</a> <a id="5828" class="Symbol">:</a> <a id="5830" href="Lecture4-notes.html#7873" data-type="Set" class="Postulate">Circle2</a> <a id="5838" class="Symbol">→</a> <a id="5840" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="5844" class="Symbol">)</a> <a id="5846" class="Symbol">(</a><a id="5847" href="Lecture5-notes.html#5847" class="Bound">n</a> <a id="5849" class="Symbol">:</a> <a id="5851" href="Lecture5-notes.html#5826" class="Bound">X</a> <a id="5853" href="Lecture4-notes.html#7890" data-type="Circle2" class="Postulate">north</a><a id="5858" class="Symbol">)</a> <a id="5860" class="Symbol">(</a><a id="5861" href="Lecture5-notes.html#5861" class="Bound">s</a> <a id="5863" class="Symbol">:</a> <a id="5865" href="Lecture5-notes.html#5826" class="Bound">X</a> <a id="5867" href="Lecture4-notes.html#7908" data-type="Circle2" class="Postulate">south</a><a id="5872" class="Symbol">)</a>
                       <a id="5897" class="Symbol">(</a><a id="5898" href="Lecture5-notes.html#5898" class="Bound">w</a> <a id="5900" class="Symbol">:</a> <a id="5902" href="Lecture5-notes.html#5847" class="Bound">n</a> <a id="5904" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">≡</a> <a id="5906" href="Lecture5-notes.html#5861" class="Bound">s</a> <a id="5908" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">[</a> <a id="5910" href="Lecture5-notes.html#5826" class="Bound">X</a> <a id="5912" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">↓</a> <a id="5914" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a> <a id="5919" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">]</a><a id="5920" class="Symbol">)</a> <a id="5922" class="Symbol">(</a><a id="5923" href="Lecture5-notes.html#5923" class="Bound">e</a> <a id="5925" class="Symbol">:</a> <a id="5927" href="Lecture5-notes.html#5847" class="Bound">n</a> <a id="5929" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">≡</a> <a id="5931" href="Lecture5-notes.html#5861" class="Bound">s</a> <a id="5933" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">[</a> <a id="5935" href="Lecture5-notes.html#5826" class="Bound">X</a> <a id="5937" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">↓</a> <a id="5939" href="Lecture4-notes.html#7950" data-type="north ≡ south" class="Postulate">east</a> <a id="5944" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">]</a><a id="5945" class="Symbol">)</a>
                     <a id="5968" class="Symbol">→</a> <a id="5970" href="Lecture5-notes.html#5381" data-type="(X : Circle2 → Set) (n : X north) (s : X south) →
PathOver X west n s → PathOver X east n s → (x : Circle2) → X x" class="Postulate">Circle2-elim</a> <a id="5983" href="Lecture5-notes.html#5826" class="Bound">X</a> <a id="5985" href="Lecture5-notes.html#5847" class="Bound">n</a> <a id="5987" href="Lecture5-notes.html#5861" class="Bound">s</a> <a id="5989" href="Lecture5-notes.html#5898" class="Bound">w</a> <a id="5991" href="Lecture5-notes.html#5923" class="Bound">e</a> <a id="5993" href="Lecture4-notes.html#7908" data-type="Circle2" class="Postulate">south</a> <a id="5999" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="6001" href="Lecture5-notes.html#5861" class="Bound">s</a>
<a id="6003" class="Symbol">{-#</a> <a id="6007" class="Keyword">REWRITE</a> <a id="6015" href="Lecture5-notes.html#5602" data-type="(X : Circle2 → Set) (n : X north) (s : X south)
(w : PathOver X west n s) (e : PathOver X east n s) →
Circle2-elim X n s w e north ≡ n" class="Postulate">Circle2-elim-north</a> <a id="6034" class="Symbol">#-}</a>
<a id="6038" class="Symbol">{-#</a> <a id="6042" class="Keyword">REWRITE</a> <a id="6050" href="Lecture5-notes.html#5804" data-type="(X : Circle2 → Set) (n : X north) (s : X south)
(w : PathOver X west n s) (e : PathOver X east n s) →
Circle2-elim X n s w e south ≡ s" class="Postulate">Circle2-elim-south</a> <a id="6069" class="Symbol">#-}</a>
<a id="6073" class="Keyword">postulate</a>
  <a id="Circle2-elim-west"></a><a id="6085" href="Lecture5-notes.html#6085" data-type="(X : Circle2 → Set) (n : X north) (s : X south)
(w : PathOver X west n s) (e : PathOver X east n s) →
apd (Circle2-elim X n s w e) west ≡ w" class="Postulate">Circle2-elim-west</a> <a id="6103" class="Symbol">:</a> <a id="6105" class="Symbol">(</a><a id="6106" href="Lecture5-notes.html#6106" class="Bound">X</a> <a id="6108" class="Symbol">:</a> <a id="6110" href="Lecture4-notes.html#7873" data-type="Set" class="Postulate">Circle2</a> <a id="6118" class="Symbol">→</a> <a id="6120" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="6124" class="Symbol">)</a> <a id="6126" class="Symbol">(</a><a id="6127" href="Lecture5-notes.html#6127" class="Bound">n</a> <a id="6129" class="Symbol">:</a> <a id="6131" href="Lecture5-notes.html#6106" class="Bound">X</a> <a id="6133" href="Lecture4-notes.html#7890" data-type="Circle2" class="Postulate">north</a><a id="6138" class="Symbol">)</a> <a id="6140" class="Symbol">(</a><a id="6141" href="Lecture5-notes.html#6141" class="Bound">s</a> <a id="6143" class="Symbol">:</a> <a id="6145" href="Lecture5-notes.html#6106" class="Bound">X</a> <a id="6147" href="Lecture4-notes.html#7908" data-type="Circle2" class="Postulate">south</a><a id="6152" class="Symbol">)</a>
                      <a id="6176" class="Symbol">(</a><a id="6177" href="Lecture5-notes.html#6177" class="Bound">w</a> <a id="6179" class="Symbol">:</a> <a id="6181" href="Lecture5-notes.html#6127" class="Bound">n</a> <a id="6183" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">≡</a> <a id="6185" href="Lecture5-notes.html#6141" class="Bound">s</a> <a id="6187" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">[</a> <a id="6189" href="Lecture5-notes.html#6106" class="Bound">X</a> <a id="6191" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">↓</a> <a id="6193" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a> <a id="6198" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">]</a><a id="6199" class="Symbol">)</a> <a id="6201" class="Symbol">(</a><a id="6202" href="Lecture5-notes.html#6202" class="Bound">e</a> <a id="6204" class="Symbol">:</a> <a id="6206" href="Lecture5-notes.html#6127" class="Bound">n</a> <a id="6208" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">≡</a> <a id="6210" href="Lecture5-notes.html#6141" class="Bound">s</a> <a id="6212" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">[</a> <a id="6214" href="Lecture5-notes.html#6106" class="Bound">X</a> <a id="6216" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">↓</a> <a id="6218" href="Lecture4-notes.html#7950" data-type="north ≡ south" class="Postulate">east</a> <a id="6223" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">]</a><a id="6224" class="Symbol">)</a>
                    <a id="6246" class="Symbol">→</a> <a id="6248" href="Lecture5-notes.html#4872" data-type="(f : (x : A) → B x) (p : a1 ≡ a2) → PathOver B p (f a1) (f a2)" class="Function">apd</a> <a id="6252" class="Symbol">(</a><a id="6253" href="Lecture5-notes.html#5381" data-type="(X : Circle2 → Set) (n : X north) (s : X south) →
PathOver X west n s → PathOver X east n s → (x : Circle2) → X x" class="Postulate">Circle2-elim</a> <a id="6266" href="Lecture5-notes.html#6106" class="Bound">X</a> <a id="6268" href="Lecture5-notes.html#6127" class="Bound">n</a> <a id="6270" href="Lecture5-notes.html#6141" class="Bound">s</a> <a id="6272" href="Lecture5-notes.html#6177" class="Bound">w</a> <a id="6274" href="Lecture5-notes.html#6202" class="Bound">e</a><a id="6275" class="Symbol">)</a> <a id="6277" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a> <a id="6282" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="6284" href="Lecture5-notes.html#6177" class="Bound">w</a>
  <a id="Circle2-elim-east"></a><a id="6288" href="Lecture5-notes.html#6288" data-type="(X : Circle2 → Set) (n : X north) (s : X south)
(w : PathOver X west n s) (e : PathOver X east n s) →
apd (Circle2-elim X n s w e) east ≡ e" class="Postulate">Circle2-elim-east</a> <a id="6306" class="Symbol">:</a> <a id="6308" class="Symbol">(</a><a id="6309" href="Lecture5-notes.html#6309" class="Bound">X</a> <a id="6311" class="Symbol">:</a> <a id="6313" href="Lecture4-notes.html#7873" data-type="Set" class="Postulate">Circle2</a> <a id="6321" class="Symbol">→</a> <a id="6323" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="6327" class="Symbol">)</a> <a id="6329" class="Symbol">(</a><a id="6330" href="Lecture5-notes.html#6330" class="Bound">n</a> <a id="6332" class="Symbol">:</a> <a id="6334" href="Lecture5-notes.html#6309" class="Bound">X</a> <a id="6336" href="Lecture4-notes.html#7890" data-type="Circle2" class="Postulate">north</a><a id="6341" class="Symbol">)</a> <a id="6343" class="Symbol">(</a><a id="6344" href="Lecture5-notes.html#6344" class="Bound">s</a> <a id="6346" class="Symbol">:</a> <a id="6348" href="Lecture5-notes.html#6309" class="Bound">X</a> <a id="6350" href="Lecture4-notes.html#7908" data-type="Circle2" class="Postulate">south</a><a id="6355" class="Symbol">)</a>
                      <a id="6379" class="Symbol">(</a><a id="6380" href="Lecture5-notes.html#6380" class="Bound">w</a> <a id="6382" class="Symbol">:</a> <a id="6384" href="Lecture5-notes.html#6330" class="Bound">n</a> <a id="6386" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">≡</a> <a id="6388" href="Lecture5-notes.html#6344" class="Bound">s</a> <a id="6390" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">[</a> <a id="6392" href="Lecture5-notes.html#6309" class="Bound">X</a> <a id="6394" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">↓</a> <a id="6396" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a> <a id="6401" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">]</a><a id="6402" class="Symbol">)</a> <a id="6404" class="Symbol">(</a><a id="6405" href="Lecture5-notes.html#6405" class="Bound">e</a> <a id="6407" class="Symbol">:</a> <a id="6409" href="Lecture5-notes.html#6330" class="Bound">n</a> <a id="6411" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">≡</a> <a id="6413" href="Lecture5-notes.html#6344" class="Bound">s</a> <a id="6415" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">[</a> <a id="6417" href="Lecture5-notes.html#6309" class="Bound">X</a> <a id="6419" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">↓</a> <a id="6421" href="Lecture4-notes.html#7950" data-type="north ≡ south" class="Postulate">east</a> <a id="6426" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">]</a><a id="6427" class="Symbol">)</a>
                    <a id="6449" class="Symbol">→</a> <a id="6451" href="Lecture5-notes.html#4872" data-type="(f : (x : A) → B x) (p : a1 ≡ a2) → PathOver B p (f a1) (f a2)" class="Function">apd</a> <a id="6455" class="Symbol">(</a><a id="6456" href="Lecture5-notes.html#5381" data-type="(X : Circle2 → Set) (n : X north) (s : X south) →
PathOver X west n s → PathOver X east n s → (x : Circle2) → X x" class="Postulate">Circle2-elim</a> <a id="6469" href="Lecture5-notes.html#6309" class="Bound">X</a> <a id="6471" href="Lecture5-notes.html#6330" class="Bound">n</a> <a id="6473" href="Lecture5-notes.html#6344" class="Bound">s</a> <a id="6475" href="Lecture5-notes.html#6380" class="Bound">w</a> <a id="6477" href="Lecture5-notes.html#6405" class="Bound">e</a><a id="6478" class="Symbol">)</a> <a id="6480" href="Lecture4-notes.html#7950" data-type="north ≡ south" class="Postulate">east</a> <a id="6485" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="6487" href="Lecture5-notes.html#6405" class="Bound">e</a>
</pre>
<h1 id="proving-equivalences">Proving equivalences</h1>
<p>One common reason dependent elims get used is to prove that functions
are mutually inverse.</p>
<pre class="Agda"><a id="6619" class="Keyword">module</a> <a id="RememberTheseFromLastTime"></a><a id="6626" href="Lecture5-notes.html#6626" class="Module">RememberTheseFromLastTime</a> <a id="6652" class="Keyword">where</a>

  <a id="RememberTheseFromLastTime.to"></a><a id="6661" href="Lecture5-notes.html#6661" data-type="S1 → Circle2" class="Function">to</a> <a id="6664" class="Symbol">:</a> <a id="6666" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a> <a id="6669" class="Symbol">→</a> <a id="6671" href="Lecture4-notes.html#7873" data-type="Set" class="Postulate">Circle2</a>
  <a id="6681" href="Lecture5-notes.html#6661" data-type="S1 → Circle2" class="Function">to</a> <a id="6684" class="Symbol">=</a> <a id="6686" href="Lecture4-notes.html#5544" data-type="(x : X) → x ≡ x → S1 → X" class="Postulate">S1-rec</a> <a id="6693" href="Lecture4-notes.html#7890" data-type="Circle2" class="Postulate">north</a> <a id="6699" class="Symbol">(</a><a id="6700" href="Lecture4-notes.html#7950" data-type="north ≡ south" class="Postulate">east</a> <a id="6705" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="6707" href="new-prelude.html#861" data-type="x ≡ y → y ≡ x" class="Function">!</a> <a id="6709" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a><a id="6713" class="Symbol">)</a>
  
  <a id="RememberTheseFromLastTime.from"></a><a id="6720" href="Lecture5-notes.html#6720" data-type="Circle2 → S1" class="Function">from</a> <a id="6725" class="Symbol">:</a> <a id="6727" href="Lecture4-notes.html#7873" data-type="Set" class="Postulate">Circle2</a> <a id="6735" class="Symbol">→</a> <a id="6737" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a>
  <a id="6742" href="Lecture5-notes.html#6720" data-type="Circle2 → S1" class="Function">from</a> <a id="6747" class="Symbol">=</a> <a id="6749" href="Lecture4-notes.html#7974" data-type="(n s : X) → n ≡ s → n ≡ s → Circle2 → X" class="Postulate">Circle2-rec</a> <a id="6761" href="Lecture4-notes.html#757" data-type="S1" class="Postulate">base</a> <a id="6766" href="Lecture4-notes.html#757" data-type="S1" class="Postulate">base</a> <a id="6771" class="Symbol">(</a><a id="6772" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="6777" href="Lecture4-notes.html#757" data-type="S1" class="Postulate">base</a><a id="6781" class="Symbol">)</a> <a id="6783" href="Lecture4-notes.html#769" data-type="base ≡ base" class="Postulate">loop</a>
  
  <a id="RememberTheseFromLastTime.from-to-north"></a><a id="6793" href="Lecture5-notes.html#6793" data-type="to (from north) ≡ north" class="Function">from-to-north</a> <a id="6807" class="Symbol">:</a> <a id="6809" href="Lecture5-notes.html#6661" data-type="S1 → Circle2" class="Function">to</a> <a id="6812" class="Symbol">(</a><a id="6813" href="Lecture5-notes.html#6720" data-type="Circle2 → S1" class="Function">from</a> <a id="6818" href="Lecture4-notes.html#7890" data-type="Circle2" class="Postulate">north</a><a id="6823" class="Symbol">)</a> <a id="6825" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="6827" href="Lecture4-notes.html#7890" data-type="Circle2" class="Postulate">north</a>
  <a id="6835" href="Lecture5-notes.html#6793" data-type="to (from north) ≡ north" class="Function">from-to-north</a> <a id="6849" class="Symbol">=</a> <a id="6851" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="6856" class="Symbol">_</a>
  
  <a id="RememberTheseFromLastTime.from-to-south"></a><a id="6863" href="Lecture5-notes.html#6863" data-type="to (from south) ≡ south" class="Function">from-to-south</a> <a id="6877" class="Symbol">:</a> <a id="6879" href="Lecture5-notes.html#6661" data-type="S1 → Circle2" class="Function">to</a> <a id="6882" class="Symbol">(</a><a id="6883" href="Lecture5-notes.html#6720" data-type="Circle2 → S1" class="Function">from</a> <a id="6888" href="Lecture4-notes.html#7908" data-type="Circle2" class="Postulate">south</a><a id="6893" class="Symbol">)</a> <a id="6895" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="6897" href="Lecture4-notes.html#7908" data-type="Circle2" class="Postulate">south</a>
  <a id="6905" href="Lecture5-notes.html#6863" data-type="to (from south) ≡ south" class="Function">from-to-south</a> <a id="6919" class="Symbol">=</a> <a id="6921" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a>
  
  <a id="RememberTheseFromLastTime.from-to-west"></a><a id="6931" href="Lecture5-notes.html#6931" data-type="(ap to (ap from west) ∙ from-to-south) ≡ west" class="Function">from-to-west</a> <a id="6944" class="Symbol">:</a> <a id="6946" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="6949" href="Lecture5-notes.html#6661" data-type="S1 → Circle2" class="Function">to</a> <a id="6952" class="Symbol">(</a><a id="6953" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="6956" href="Lecture5-notes.html#6720" data-type="Circle2 → S1" class="Function">from</a> <a id="6961" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a><a id="6965" class="Symbol">)</a> <a id="6967" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="6969" href="Lecture5-notes.html#6863" data-type="to (from south) ≡ south" class="Function">from-to-south</a> <a id="6983" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="6985" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a>
  <a id="6992" href="Lecture5-notes.html#6931" data-type="(ap to (ap from west) ∙ from-to-south) ≡ west" class="Function">from-to-west</a> <a id="7005" class="Symbol">=</a> <a id="7007" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="7010" href="Lecture5-notes.html#6661" data-type="S1 → Circle2" class="Function">to</a> <a id="7013" class="Symbol">(</a><a id="7014" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="7017" href="Lecture5-notes.html#6720" data-type="Circle2 → S1" class="Function">from</a> <a id="7022" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a><a id="7026" class="Symbol">)</a> <a id="7028" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7030" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a> <a id="7035" href="new-prelude.html#1517" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="7038" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="7041" class="Symbol">(\</a> <a id="7044" href="Lecture5-notes.html#7044" class="Bound">H</a> <a id="7046" class="Symbol">→</a> <a id="7048" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="7051" href="Lecture5-notes.html#6661" data-type="S1 → Circle2" class="Function">to</a> <a id="7054" href="Lecture5-notes.html#7044" class="Bound">H</a> <a id="7056" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7058" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a><a id="7062" class="Symbol">)</a> <a id="7064" class="Symbol">(</a><a id="7065" href="Lecture4-notes.html#8400" data-type="(n s : X) (w e : n ≡ s) → ap (Circle2-rec n s w e) west ≡ w" class="Postulate">Circle2-rec-west</a> <a id="7082" class="Symbol">_</a> <a id="7084" class="Symbol">_</a> <a id="7086" class="Symbol">_</a> <a id="7088" class="Symbol">_)</a> <a id="7091" href="new-prelude.html#1517" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
                  <a id="7111" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="7114" href="Lecture5-notes.html#6661" data-type="S1 → Circle2" class="Function">to</a> <a id="7117" class="Symbol">(</a><a id="7118" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="7123" href="Lecture4-notes.html#757" data-type="S1" class="Postulate">base</a><a id="7127" class="Symbol">)</a> <a id="7129" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7131" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a>    <a id="7139" href="new-prelude.html#1517" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="7142" href="Lecture4-notes.html#2745" data-type="(p : x ≡ y) → (refl x ∙ p) ≡ p" class="Function">∙unit-l</a> <a id="7150" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a> <a id="7155" href="new-prelude.html#1517" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
                  <a id="7175" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a> <a id="7180" href="new-prelude.html#1613" data-type="(x : X) → x ≡ x" class="Function Operator">∎</a> 
  
  <a id="RememberTheseFromLastTime.from-to-east"></a><a id="7188" href="Lecture5-notes.html#7188" data-type="(ap to (ap from east) ∙ from-to-south) ≡ east" class="Function">from-to-east</a> <a id="7201" class="Symbol">:</a> <a id="7203" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="7206" href="Lecture5-notes.html#6661" data-type="S1 → Circle2" class="Function">to</a> <a id="7209" class="Symbol">(</a><a id="7210" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="7213" href="Lecture5-notes.html#6720" data-type="Circle2 → S1" class="Function">from</a> <a id="7218" href="Lecture4-notes.html#7950" data-type="north ≡ south" class="Postulate">east</a><a id="7222" class="Symbol">)</a> <a id="7224" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7226" href="Lecture5-notes.html#6863" data-type="to (from south) ≡ south" class="Function">from-to-south</a> <a id="7240" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="7242" href="Lecture4-notes.html#7950" data-type="north ≡ south" class="Postulate">east</a>
  <a id="7249" href="Lecture5-notes.html#7188" data-type="(ap to (ap from east) ∙ from-to-south) ≡ east" class="Function">from-to-east</a> <a id="7262" class="Symbol">=</a> <a id="7264" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="7267" href="Lecture5-notes.html#6661" data-type="S1 → Circle2" class="Function">to</a> <a id="7270" class="Symbol">(</a><a id="7271" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="7274" href="Lecture5-notes.html#6720" data-type="Circle2 → S1" class="Function">from</a> <a id="7279" href="Lecture4-notes.html#7950" data-type="north ≡ south" class="Postulate">east</a><a id="7283" class="Symbol">)</a> <a id="7285" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7287" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a> <a id="7292" href="new-prelude.html#1517" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="7295" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="7298" class="Symbol">(\</a> <a id="7301" href="Lecture5-notes.html#7301" class="Bound">H</a> <a id="7303" class="Symbol">→</a> <a id="7305" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="7308" href="Lecture5-notes.html#6661" data-type="S1 → Circle2" class="Function">to</a> <a id="7311" href="Lecture5-notes.html#7301" class="Bound">H</a> <a id="7313" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7315" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a><a id="7319" class="Symbol">)</a> <a id="7321" class="Symbol">(</a><a id="7322" href="Lecture4-notes.html#8527" data-type="(n s : X) (w e : n ≡ s) → ap (Circle2-rec n s w e) east ≡ e" class="Postulate">Circle2-rec-east</a> <a id="7339" class="Symbol">_</a> <a id="7341" class="Symbol">_</a> <a id="7343" class="Symbol">_</a> <a id="7345" class="Symbol">_)</a> <a id="7348" href="new-prelude.html#1517" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
                 <a id="7367" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="7370" href="Lecture5-notes.html#6661" data-type="S1 → Circle2" class="Function">to</a> <a id="7373" href="Lecture4-notes.html#769" data-type="base ≡ base" class="Postulate">loop</a> <a id="7378" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7380" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a>           <a id="7395" href="new-prelude.html#1517" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="7398" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="7401" class="Symbol">(\</a> <a id="7404" href="Lecture5-notes.html#7404" class="Bound">H</a> <a id="7406" class="Symbol">→</a> <a id="7408" href="Lecture5-notes.html#7404" class="Bound">H</a> <a id="7410" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7412" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a><a id="7416" class="Symbol">)</a> <a id="7418" class="Symbol">(</a><a id="7419" href="Lecture4-notes.html#6311" data-type="(x : X) (p : x ≡ x) → ap (S1-rec x p) loop ≡ p" class="Postulate">S1-rec-loop</a> <a id="7431" class="Symbol">_</a> <a id="7433" class="Symbol">_)</a> <a id="7436" href="new-prelude.html#1517" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
                 <a id="7455" href="Lecture4-notes.html#7950" data-type="north ≡ south" class="Postulate">east</a> <a id="7460" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7462" href="new-prelude.html#861" data-type="x ≡ y → y ≡ x" class="Function">!</a> <a id="7464" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a> <a id="7469" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7471" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a>        <a id="7483" href="new-prelude.html#1517" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="7486" href="new-prelude.html#861" data-type="x ≡ y → y ≡ x" class="Function">!</a> <a id="7488" class="Symbol">(</a><a id="7489" href="Lecture4-notes.html#2836" data-type="(p : x ≡ y) (q : y ≡ z) (r : z ≡ w) → (p ∙ (q ∙ r)) ≡ ((p ∙ q) ∙ r)" class="Function">∙assoc</a> <a id="7496" class="Symbol">_</a> <a id="7498" class="Symbol">(</a><a id="7499" href="new-prelude.html#861" data-type="x ≡ y → y ≡ x" class="Function">!</a> <a id="7501" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a><a id="7505" class="Symbol">)</a> <a id="7507" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a><a id="7511" class="Symbol">)</a> <a id="7513" href="new-prelude.html#1517" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
                 <a id="7532" href="Lecture4-notes.html#7950" data-type="north ≡ south" class="Postulate">east</a> <a id="7537" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7539" class="Symbol">(</a><a id="7540" href="new-prelude.html#861" data-type="x ≡ y → y ≡ x" class="Function">!</a> <a id="7542" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a> <a id="7547" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7549" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a><a id="7553" class="Symbol">)</a>      <a id="7560" href="new-prelude.html#1517" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">≡⟨</a> <a id="7563" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="7566" class="Symbol">(\</a> <a id="7569" href="Lecture5-notes.html#7569" class="Bound">H</a> <a id="7571" class="Symbol">→</a> <a id="7573" href="Lecture4-notes.html#7950" data-type="north ≡ south" class="Postulate">east</a> <a id="7578" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7580" href="Lecture5-notes.html#7569" class="Bound">H</a><a id="7581" class="Symbol">)</a> <a id="7583" class="Symbol">(</a><a id="7584" href="Lecture4-notes.html#2981" data-type="(p : x ≡ y) → (! p ∙ p) ≡ refl y" class="Function">!-inv-l</a> <a id="7592" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a><a id="7596" class="Symbol">)</a> <a id="7598" href="new-prelude.html#1517" data-type="(x : X) → x ≡ y → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
                 <a id="7617" href="Lecture4-notes.html#7950" data-type="north ≡ south" class="Postulate">east</a> <a id="7622" href="new-prelude.html#1613" data-type="(x : X) → x ≡ x" class="Function Operator">∎</a>
<a id="7624" class="Keyword">open</a> <a id="7629" href="Lecture5-notes.html#6626" class="Module">RememberTheseFromLastTime</a> <a id="7655" class="Keyword">public</a>
</pre>
<pre class="Agda"><a id="PathOver-roundtrip≡"></a><a id="7675" href="Lecture5-notes.html#7675" data-type="(g : B → A) (f : A → B) (p : a ≡ a&#39;) →
(! q ∙ (ap g (ap f p) ∙ r)) ≡ p →
PathOver (λ x → g (f x) ≡ x) p q r" class="Function">PathOver-roundtrip≡</a> <a id="7695" class="Symbol">:</a> <a id="7697" class="Symbol">∀</a> <a id="7699" class="Symbol">{</a><a id="7700" href="Lecture5-notes.html#7700" class="Bound">A</a> <a id="7702" href="Lecture5-notes.html#7702" class="Bound">B</a> <a id="7704" class="Symbol">:</a> <a id="7706" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="7710" class="Symbol">}</a> <a id="7712" class="Symbol">(</a><a id="7713" href="Lecture5-notes.html#7713" class="Bound">g</a> <a id="7715" class="Symbol">:</a> <a id="7717" href="Lecture5-notes.html#7702" class="Bound">B</a> <a id="7719" class="Symbol">→</a> <a id="7721" href="Lecture5-notes.html#7700" class="Bound">A</a><a id="7722" class="Symbol">)</a> <a id="7724" class="Symbol">(</a><a id="7725" href="Lecture5-notes.html#7725" class="Bound">f</a> <a id="7727" class="Symbol">:</a> <a id="7729" href="Lecture5-notes.html#7700" class="Bound">A</a> <a id="7731" class="Symbol">→</a> <a id="7733" href="Lecture5-notes.html#7702" class="Bound">B</a><a id="7734" class="Symbol">)</a>
                        <a id="7760" class="Symbol">{</a><a id="7761" href="Lecture5-notes.html#7761" class="Bound">a</a> <a id="7763" href="Lecture5-notes.html#7763" class="Bound">a&#39;</a> <a id="7766" class="Symbol">:</a> <a id="7768" href="Lecture5-notes.html#7700" class="Bound">A</a><a id="7769" class="Symbol">}</a> <a id="7771" class="Symbol">(</a><a id="7772" href="Lecture5-notes.html#7772" class="Bound">p</a> <a id="7774" class="Symbol">:</a> <a id="7776" href="Lecture5-notes.html#7761" class="Bound">a</a> <a id="7778" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="7780" href="Lecture5-notes.html#7763" class="Bound">a&#39;</a><a id="7782" class="Symbol">)</a>
                        <a id="7808" class="Symbol">{</a><a id="7809" href="Lecture5-notes.html#7809" class="Bound">q</a> <a id="7811" class="Symbol">:</a> <a id="7813" href="Lecture5-notes.html#7713" class="Bound">g</a> <a id="7815" class="Symbol">(</a><a id="7816" href="Lecture5-notes.html#7725" class="Bound">f</a> <a id="7818" href="Lecture5-notes.html#7761" class="Bound">a</a><a id="7819" class="Symbol">)</a> <a id="7821" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="7823" href="Lecture5-notes.html#7761" class="Bound">a</a><a id="7824" class="Symbol">}</a>
                        <a id="7850" class="Symbol">{</a><a id="7851" href="Lecture5-notes.html#7851" class="Bound">r</a> <a id="7853" class="Symbol">:</a> <a id="7855" href="Lecture5-notes.html#7713" class="Bound">g</a> <a id="7857" class="Symbol">(</a><a id="7858" href="Lecture5-notes.html#7725" class="Bound">f</a> <a id="7860" href="Lecture5-notes.html#7763" class="Bound">a&#39;</a><a id="7862" class="Symbol">)</a> <a id="7864" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="7866" href="Lecture5-notes.html#7763" class="Bound">a&#39;</a><a id="7868" class="Symbol">}</a>
                      <a id="7892" class="Symbol">→</a> <a id="7894" href="new-prelude.html#861" data-type="x ≡ y → y ≡ x" class="Function">!</a> <a id="7896" href="Lecture5-notes.html#7809" class="Bound">q</a> <a id="7898" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7900" class="Symbol">((</a><a id="7902" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="7905" href="Lecture5-notes.html#7713" class="Bound">g</a> <a id="7907" class="Symbol">(</a><a id="7908" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="7911" href="Lecture5-notes.html#7725" class="Bound">f</a> <a id="7913" href="Lecture5-notes.html#7772" class="Bound">p</a><a id="7914" class="Symbol">))</a> <a id="7917" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7919" href="Lecture5-notes.html#7851" class="Bound">r</a><a id="7920" class="Symbol">)</a> <a id="7922" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="7924" href="Lecture5-notes.html#7772" class="Bound">p</a>
                      <a id="7948" class="Symbol">→</a> <a id="7950" href="Lecture5-notes.html#7809" class="Bound">q</a> <a id="7952" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">≡</a> <a id="7954" href="Lecture5-notes.html#7851" class="Bound">r</a> <a id="7956" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">[</a> <a id="7958" class="Symbol">(\</a> <a id="7961" href="Lecture5-notes.html#7961" class="Bound">x</a> <a id="7963" class="Symbol">→</a> <a id="7965" href="Lecture5-notes.html#7713" class="Bound">g</a> <a id="7967" class="Symbol">(</a><a id="7968" href="Lecture5-notes.html#7725" class="Bound">f</a> <a id="7970" href="Lecture5-notes.html#7961" class="Bound">x</a><a id="7971" class="Symbol">)</a> <a id="7973" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="7975" href="Lecture5-notes.html#7961" class="Bound">x</a><a id="7976" class="Symbol">)</a> <a id="7978" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">↓</a> <a id="7980" href="Lecture5-notes.html#7772" class="Bound">p</a> <a id="7982" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">]</a>
<a id="7984" href="Lecture5-notes.html#7675" data-type="(g : B → A) (f : A → B) (p : a ≡ a&#39;) →
(! q ∙ (ap g (ap f p) ∙ r)) ≡ p →
PathOver (λ x → g (f x) ≡ x) p q r" class="Function">PathOver-roundtrip≡</a> <a id="8004" href="Lecture5-notes.html#8004" class="Bound">g</a> <a id="8006" href="Lecture5-notes.html#8006" class="Bound">f</a>  <a id="8009" class="Symbol">(</a><a id="8010" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="8015" class="Symbol">_)</a> <a id="8018" class="Symbol">{</a><a id="8019" class="Argument">q</a> <a id="8021" class="Symbol">=</a> <a id="8023" href="Lecture5-notes.html#8023" class="Bound">q</a><a id="8024" class="Symbol">}</a> <a id="8026" class="Symbol">{</a><a id="8027" href="Lecture5-notes.html#8027" class="Bound">r</a><a id="8028" class="Symbol">}</a> <a id="8030" href="Lecture5-notes.html#8030" class="Bound">h</a> <a id="8032" class="Symbol">=</a>
  <a id="8036" href="Lecture5-notes.html#4578" data-type="x ≡ y → PathOver B (refl a) x y" class="Function">path-to-pathover</a> <a id="8053" class="Symbol">(</a><a id="8054" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="8057" class="Symbol">(\</a> <a id="8060" href="Lecture5-notes.html#8060" class="Bound">H</a> <a id="8062" class="Symbol">→</a> <a id="8064" href="Lecture5-notes.html#8023" class="Bound">q</a> <a id="8066" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8068" href="Lecture5-notes.html#8060" class="Bound">H</a><a id="8069" class="Symbol">)</a> <a id="8071" class="Symbol">(</a><a id="8072" href="new-prelude.html#861" data-type="x ≡ y → y ≡ x" class="Function">!</a> <a id="8074" href="Lecture5-notes.html#8030" class="Bound">h</a><a id="8075" class="Symbol">)</a> <a id="8077" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a>
                    <a id="8099" class="Symbol">(</a> <a id="8101" href="Lecture4-notes.html#2836" data-type="(p : x ≡ y) (q : y ≡ z) (r : z ≡ w) → (p ∙ (q ∙ r)) ≡ ((p ∙ q) ∙ r)" class="Function">∙assoc</a> <a id="8108" class="Symbol">_</a> <a id="8110" class="Symbol">_</a> <a id="8112" class="Symbol">(</a><a id="8113" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="8118" class="Symbol">_</a> <a id="8120" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8122" href="Lecture5-notes.html#8027" class="Bound">r</a><a id="8123" class="Symbol">)</a> <a id="8125" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a>
                    <a id="8147" class="Symbol">(</a><a id="8148" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="8151" class="Symbol">(\</a> <a id="8154" href="Lecture5-notes.html#8154" class="Bound">H</a> <a id="8156" class="Symbol">→</a> <a id="8158" href="Lecture5-notes.html#8154" class="Bound">H</a> <a id="8160" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8162" class="Symbol">(</a><a id="8163" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="8168" class="Symbol">_</a> <a id="8170" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8172" href="Lecture5-notes.html#8027" class="Bound">r</a><a id="8173" class="Symbol">))</a> <a id="8176" class="Symbol">(</a><a id="8177" href="Lecture4-notes.html#3074" data-type="(p : x ≡ y) → (p ∙ ! p) ≡ refl x" class="Function">!-inv-r</a> <a id="8185" href="Lecture5-notes.html#8023" class="Bound">q</a><a id="8186" class="Symbol">)</a> <a id="8188" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a>
                    <a id="8210" class="Symbol">(</a><a id="8211" href="Lecture4-notes.html#2745" data-type="(p : x ≡ y) → (refl x ∙ p) ≡ p" class="Function">∙unit-l</a> <a id="8219" class="Symbol">(</a><a id="8220" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="8225" class="Symbol">_</a> <a id="8227" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8229" href="Lecture5-notes.html#8027" class="Bound">r</a><a id="8230" class="Symbol">)</a> <a id="8232" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a>  <a id="8235" href="Lecture4-notes.html#2745" data-type="(p : x ≡ y) → (refl x ∙ p) ≡ p" class="Function">∙unit-l</a> <a id="8243" href="Lecture5-notes.html#8027" class="Bound">r</a> <a id="8245" class="Symbol">))</a> <a id="8248" class="Symbol">))</a>

<a id="from-to"></a><a id="8252" href="Lecture5-notes.html#8252" data-type="(y : Circle2) → to (from y) ≡ y" class="Function">from-to</a> <a id="8260" class="Symbol">:</a> <a id="8262" class="Symbol">(</a><a id="8263" href="Lecture5-notes.html#8263" class="Bound">y</a> <a id="8265" class="Symbol">:</a> <a id="8267" href="Lecture4-notes.html#7873" data-type="Set" class="Postulate">Circle2</a><a id="8274" class="Symbol">)</a> <a id="8276" class="Symbol">→</a> <a id="8278" href="Lecture5-notes.html#6661" data-type="S1 → Circle2" class="Function">to</a> <a id="8281" class="Symbol">(</a><a id="8282" href="Lecture5-notes.html#6720" data-type="Circle2 → S1" class="Function">from</a> <a id="8287" href="Lecture5-notes.html#8263" class="Bound">y</a><a id="8288" class="Symbol">)</a> <a id="8290" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="8292" href="Lecture5-notes.html#8263" class="Bound">y</a>
<a id="8294" href="Lecture5-notes.html#8252" data-type="(y : Circle2) → to (from y) ≡ y" class="Function">from-to</a> <a id="8302" class="Symbol">=</a> <a id="8304" href="Lecture5-notes.html#5381" data-type="(X : Circle2 → Set) (n : X north) (s : X south) →
PathOver X west n s → PathOver X east n s → (x : Circle2) → X x" class="Postulate">Circle2-elim</a> <a id="8317" class="Symbol">_</a>
                       <a id="8342" href="Lecture5-notes.html#6793" data-type="to (from north) ≡ north" class="Function">from-to-north</a>
                       <a id="8379" href="Lecture5-notes.html#6863" data-type="to (from south) ≡ south" class="Function">from-to-south</a>
                       <a id="8416" class="Symbol">(</a><a id="8417" href="Lecture5-notes.html#7675" data-type="(g : B → A) (f : A → B) (p : a ≡ a&#39;) →
(! q ∙ (ap g (ap f p) ∙ r)) ≡ p →
PathOver (λ x → g (f x) ≡ x) p q r" class="Function">PathOver-roundtrip≡</a> <a id="8437" href="Lecture5-notes.html#6661" data-type="S1 → Circle2" class="Function">to</a> <a id="8440" href="Lecture5-notes.html#6720" data-type="Circle2 → S1" class="Function">from</a> <a id="8445" href="Lecture4-notes.html#7926" data-type="north ≡ south" class="Postulate">west</a> <a id="8450" class="Symbol">(</a><a id="8451" href="Lecture4-notes.html#2745" data-type="(p : x ≡ y) → (refl x ∙ p) ≡ p" class="Function">∙unit-l</a> <a id="8459" class="Symbol">_</a> <a id="8461" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8463" href="Lecture5-notes.html#6931" data-type="(ap to (ap from west) ∙ from-to-south) ≡ west" class="Function">from-to-west</a><a id="8475" class="Symbol">))</a>
                       <a id="8501" class="Symbol">(</a><a id="8502" href="Lecture5-notes.html#7675" data-type="(g : B → A) (f : A → B) (p : a ≡ a&#39;) →
(! q ∙ (ap g (ap f p) ∙ r)) ≡ p →
PathOver (λ x → g (f x) ≡ x) p q r" class="Function">PathOver-roundtrip≡</a> <a id="8522" href="Lecture5-notes.html#6661" data-type="S1 → Circle2" class="Function">to</a> <a id="8525" href="Lecture5-notes.html#6720" data-type="Circle2 → S1" class="Function">from</a> <a id="8530" href="Lecture4-notes.html#7950" data-type="north ≡ south" class="Postulate">east</a> <a id="8535" class="Symbol">(</a><a id="8536" href="Lecture4-notes.html#2745" data-type="(p : x ≡ y) → (refl x ∙ p) ≡ p" class="Function">∙unit-l</a> <a id="8544" class="Symbol">_</a> <a id="8546" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8548" href="Lecture5-notes.html#7188" data-type="(ap to (ap from east) ∙ from-to-south) ≡ east" class="Function">from-to-east</a><a id="8560" class="Symbol">))</a>
</pre>
<p>To do the other direction you’ll need</p>
<pre class="Agda"><a id="8612" class="Keyword">postulate</a>
  <a id="S1-elim"></a><a id="8624" href="Lecture5-notes.html#8624" data-type="(X : S1 → Set) (x : X base) →
PathOver X loop x x → (x₁ : S1) → X x₁" class="Postulate">S1-elim</a> <a id="8632" class="Symbol">:</a> <a id="8634" class="Symbol">(</a><a id="8635" href="Lecture5-notes.html#8635" class="Bound">X</a> <a id="8637" class="Symbol">:</a> <a id="8639" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a> <a id="8642" class="Symbol">→</a> <a id="8644" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="8648" class="Symbol">)</a>
            <a id="8662" class="Symbol">(</a><a id="8663" href="Lecture5-notes.html#8663" class="Bound">x</a> <a id="8665" class="Symbol">:</a> <a id="8667" href="Lecture5-notes.html#8635" class="Bound">X</a> <a id="8669" href="Lecture4-notes.html#757" data-type="S1" class="Postulate">base</a><a id="8673" class="Symbol">)</a>
            <a id="8687" class="Symbol">(</a><a id="8688" href="Lecture5-notes.html#8688" class="Bound">p</a> <a id="8690" class="Symbol">:</a> <a id="8692" href="Lecture5-notes.html#8663" class="Bound">x</a> <a id="8694" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">≡</a> <a id="8696" href="Lecture5-notes.html#8663" class="Bound">x</a> <a id="8698" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">[</a> <a id="8700" href="Lecture5-notes.html#8635" class="Bound">X</a> <a id="8702" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">↓</a> <a id="8704" href="Lecture4-notes.html#769" data-type="base ≡ base" class="Postulate">loop</a> <a id="8709" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">]</a><a id="8710" class="Symbol">)</a>
          <a id="8722" class="Symbol">→</a> <a id="8724" class="Symbol">(</a><a id="8725" href="Lecture5-notes.html#8725" class="Bound">x</a> <a id="8727" class="Symbol">:</a> <a id="8729" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a><a id="8731" class="Symbol">)</a> <a id="8733" class="Symbol">→</a> <a id="8735" href="Lecture5-notes.html#8635" class="Bound">X</a> <a id="8737" href="Lecture5-notes.html#8725" class="Bound">x</a>
  
  <a id="S1-elim-base"></a><a id="8744" href="Lecture5-notes.html#8744" data-type="(X : S1 → Set) (x : X base) (p : PathOver X loop x x) →
S1-elim X x p base ≡ x" class="Postulate">S1-elim-base</a> <a id="8757" class="Symbol">:</a> <a id="8759" class="Symbol">(</a><a id="8760" href="Lecture5-notes.html#8760" class="Bound">X</a> <a id="8762" class="Symbol">:</a> <a id="8764" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a> <a id="8767" class="Symbol">→</a> <a id="8769" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="8773" class="Symbol">)</a>
                 <a id="8792" class="Symbol">(</a><a id="8793" href="Lecture5-notes.html#8793" class="Bound">x</a> <a id="8795" class="Symbol">:</a> <a id="8797" href="Lecture5-notes.html#8760" class="Bound">X</a> <a id="8799" href="Lecture4-notes.html#757" data-type="S1" class="Postulate">base</a><a id="8803" class="Symbol">)</a>
                 <a id="8822" class="Symbol">(</a><a id="8823" href="Lecture5-notes.html#8823" class="Bound">p</a> <a id="8825" class="Symbol">:</a> <a id="8827" href="Lecture5-notes.html#8793" class="Bound">x</a> <a id="8829" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">≡</a> <a id="8831" href="Lecture5-notes.html#8793" class="Bound">x</a> <a id="8833" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">[</a> <a id="8835" href="Lecture5-notes.html#8760" class="Bound">X</a> <a id="8837" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">↓</a> <a id="8839" href="Lecture4-notes.html#769" data-type="base ≡ base" class="Postulate">loop</a> <a id="8844" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">]</a><a id="8845" class="Symbol">)</a>
               <a id="8862" class="Symbol">→</a> <a id="8864" href="Lecture5-notes.html#8624" data-type="(X : S1 → Set) (x : X base) →
PathOver X loop x x → (x₁ : S1) → X x₁" class="Postulate">S1-elim</a> <a id="8872" href="Lecture5-notes.html#8760" class="Bound">X</a> <a id="8874" href="Lecture5-notes.html#8793" class="Bound">x</a> <a id="8876" href="Lecture5-notes.html#8823" class="Bound">p</a> <a id="8878" href="Lecture4-notes.html#757" data-type="S1" class="Postulate">base</a> <a id="8883" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="8885" href="Lecture5-notes.html#8793" class="Bound">x</a>

<a id="8888" class="Symbol">{-#</a> <a id="8892" class="Keyword">REWRITE</a> <a id="8900" href="Lecture5-notes.html#8744" data-type="(X : S1 → Set) (x : X base) (p : PathOver X loop x x) →
S1-elim X x p base ≡ x" class="Postulate">S1-elim-base</a> <a id="8913" class="Symbol">#-}</a>
<a id="8917" class="Keyword">postulate</a>
  <a id="S1-elim-loop"></a><a id="8929" href="Lecture5-notes.html#8929" data-type="(X : S1 → Set) (x : X base) (p : PathOver X loop x x) →
apd (S1-elim X x p) loop ≡ p" class="Postulate">S1-elim-loop</a> <a id="8942" class="Symbol">:</a> <a id="8944" class="Symbol">(</a><a id="8945" href="Lecture5-notes.html#8945" class="Bound">X</a> <a id="8947" class="Symbol">:</a> <a id="8949" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a> <a id="8952" class="Symbol">→</a> <a id="8954" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="8958" class="Symbol">)</a>
                 <a id="8977" class="Symbol">(</a><a id="8978" href="Lecture5-notes.html#8978" class="Bound">x</a> <a id="8980" class="Symbol">:</a> <a id="8982" href="Lecture5-notes.html#8945" class="Bound">X</a> <a id="8984" href="Lecture4-notes.html#757" data-type="S1" class="Postulate">base</a><a id="8988" class="Symbol">)</a>
                 <a id="9007" class="Symbol">(</a><a id="9008" href="Lecture5-notes.html#9008" class="Bound">p</a> <a id="9010" class="Symbol">:</a> <a id="9012" href="Lecture5-notes.html#8978" class="Bound">x</a> <a id="9014" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">≡</a> <a id="9016" href="Lecture5-notes.html#8978" class="Bound">x</a> <a id="9018" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">[</a> <a id="9020" href="Lecture5-notes.html#8945" class="Bound">X</a> <a id="9022" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">↓</a> <a id="9024" href="Lecture4-notes.html#769" data-type="base ≡ base" class="Postulate">loop</a> <a id="9029" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">]</a><a id="9030" class="Symbol">)</a>
               <a id="9047" class="Symbol">→</a> <a id="9049" href="Lecture5-notes.html#4872" data-type="(f : (x : A) → B x) (p : a1 ≡ a2) → PathOver B p (f a1) (f a2)" class="Function">apd</a> <a id="9053" class="Symbol">(</a><a id="9054" href="Lecture5-notes.html#8624" data-type="(X : S1 → Set) (x : X base) →
PathOver X loop x x → (x₁ : S1) → X x₁" class="Postulate">S1-elim</a> <a id="9062" href="Lecture5-notes.html#8945" class="Bound">X</a> <a id="9064" href="Lecture5-notes.html#8978" class="Bound">x</a> <a id="9066" href="Lecture5-notes.html#9008" class="Bound">p</a><a id="9067" class="Symbol">)</a> <a id="9069" href="Lecture4-notes.html#769" data-type="base ≡ base" class="Postulate">loop</a> <a id="9074" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="9076" href="Lecture5-notes.html#9008" class="Bound">p</a>
</pre>
<h1 id="multiplication-on-the-circle">Multiplication on the circle</h1>
<p>Classically, if you think of the points on the circle as complex
numbers, you can multiply two points, and the result will represent a
point on the circle. There is a synthetic version of this operation in
type theory. Defining it uses S1-elim and <em>function
extensionality</em>, which says that paths between functions are
homotopies.</p>
<pre class="Agda"><a id="PathOver-path-loop"></a><a id="9459" href="Lecture5-notes.html#9459" data-type="(q ∙ p) ≡ (p ∙ r) → PathOver (λ x → x ≡ x) p q r" class="Function">PathOver-path-loop</a> <a id="9478" class="Symbol">:</a> <a id="9480" class="Symbol">∀</a> <a id="9482" class="Symbol">{</a><a id="9483" href="Lecture5-notes.html#9483" class="Bound">A</a> <a id="9485" class="Symbol">:</a> <a id="9487" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="9491" class="Symbol">}</a> 
                     <a id="9515" class="Symbol">{</a><a id="9516" href="Lecture5-notes.html#9516" class="Bound">a</a> <a id="9518" href="Lecture5-notes.html#9518" class="Bound">a&#39;</a> <a id="9521" class="Symbol">:</a> <a id="9523" href="Lecture5-notes.html#9483" class="Bound">A</a><a id="9524" class="Symbol">}</a> <a id="9526" class="Symbol">{</a><a id="9527" href="Lecture5-notes.html#9527" class="Bound">p</a> <a id="9529" class="Symbol">:</a> <a id="9531" href="Lecture5-notes.html#9516" class="Bound">a</a> <a id="9533" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="9535" href="Lecture5-notes.html#9518" class="Bound">a&#39;</a><a id="9537" class="Symbol">}</a>
                     <a id="9560" class="Symbol">{</a><a id="9561" href="Lecture5-notes.html#9561" class="Bound">q</a> <a id="9563" class="Symbol">:</a> <a id="9565" href="Lecture5-notes.html#9516" class="Bound">a</a> <a id="9567" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="9569" href="Lecture5-notes.html#9516" class="Bound">a</a><a id="9570" class="Symbol">}</a>
                     <a id="9593" class="Symbol">{</a><a id="9594" href="Lecture5-notes.html#9594" class="Bound">r</a> <a id="9596" class="Symbol">:</a> <a id="9598" href="Lecture5-notes.html#9518" class="Bound">a&#39;</a> <a id="9601" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="9603" href="Lecture5-notes.html#9518" class="Bound">a&#39;</a><a id="9605" class="Symbol">}</a>
                   <a id="9626" class="Symbol">→</a> <a id="9628" href="Lecture5-notes.html#9561" class="Bound">q</a> <a id="9630" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="9632" href="Lecture5-notes.html#9527" class="Bound">p</a> <a id="9634" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="9636" href="Lecture5-notes.html#9527" class="Bound">p</a> <a id="9638" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="9640" href="Lecture5-notes.html#9594" class="Bound">r</a>
                   <a id="9661" class="Symbol">→</a> <a id="9663" href="Lecture5-notes.html#9561" class="Bound">q</a> <a id="9665" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">≡</a> <a id="9667" href="Lecture5-notes.html#9594" class="Bound">r</a> <a id="9669" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">[</a> <a id="9671" class="Symbol">(\</a> <a id="9674" href="Lecture5-notes.html#9674" class="Bound">x</a> <a id="9676" class="Symbol">→</a> <a id="9678" href="Lecture5-notes.html#9674" class="Bound">x</a> <a id="9680" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="9682" href="Lecture5-notes.html#9674" class="Bound">x</a><a id="9683" class="Symbol">)</a> <a id="9685" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">↓</a> <a id="9687" href="Lecture5-notes.html#9527" class="Bound">p</a> <a id="9689" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">]</a>
<a id="9691" href="Lecture5-notes.html#9459" data-type="(q ∙ p) ≡ (p ∙ r) → PathOver (λ x → x ≡ x) p q r" class="Function">PathOver-path-loop</a> <a id="9710" class="Symbol">{</a><a id="9711" class="Argument">p</a> <a id="9713" class="Symbol">=</a> <a id="9715" class="Symbol">(</a><a id="9716" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="9721" class="Symbol">_)}</a> <a id="9725" href="Lecture5-notes.html#9725" class="Bound">h</a> <a id="9727" class="Symbol">=</a> <a id="9729" href="Lecture5-notes.html#4578" data-type="x ≡ y → PathOver B (refl a) x y" class="Function">path-to-pathover</a> <a id="9746" class="Symbol">(</a><a id="9747" href="Lecture5-notes.html#9725" class="Bound">h</a> <a id="9749" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="9751" class="Symbol">(</a><a id="9752" href="Lecture4-notes.html#2745" data-type="(p : x ≡ y) → (refl x ∙ p) ≡ p" class="Function">∙unit-l</a> <a id="9760" class="Symbol">_))</a> 

<a id="mult"></a><a id="9766" href="Lecture5-notes.html#9766" data-type="S1 → S1 → S1" class="Function">mult</a> <a id="9771" class="Symbol">:</a> <a id="9773" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a> <a id="9776" class="Symbol">→</a> <a id="9778" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a> <a id="9781" class="Symbol">→</a> <a id="9783" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a>
<a id="9786" href="Lecture5-notes.html#9766" data-type="S1 → S1 → S1" class="Function">mult</a> <a id="9791" class="Symbol">=</a> <a id="9793" href="Lecture4-notes.html#5544" data-type="(x : X) → x ≡ x → S1 → X" class="Postulate">S1-rec</a> <a id="9800" class="Symbol">((\</a> <a id="9804" href="Lecture5-notes.html#9804" class="Bound">y</a> <a id="9806" class="Symbol">→</a> <a id="9808" href="Lecture5-notes.html#9804" class="Bound">y</a><a id="9809" class="Symbol">))</a> <a id="9812" class="Symbol">(</a><a id="9813" href="new-prelude.html#2559" data-type="f ∼ g → f ≡ g" class="Postulate">λ≡</a> <a id="9816" class="Symbol">(</a><a id="9817" href="Lecture5-notes.html#8624" data-type="(X : S1 → Set) (x : X base) →
PathOver X loop x x → (x₁ : S1) → X x₁" class="Postulate">S1-elim</a> <a id="9825" class="Symbol">(λ</a> <a id="9828" href="Lecture5-notes.html#9828" class="Bound">z</a> <a id="9830" class="Symbol">→</a> <a id="9832" href="Lecture5-notes.html#9828" class="Bound">z</a> <a id="9834" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="9836" href="Lecture5-notes.html#9828" class="Bound">z</a><a id="9837" class="Symbol">)</a> <a id="9839" href="Lecture4-notes.html#769" data-type="base ≡ base" class="Postulate">loop</a> <a id="9844" class="Symbol">(</a><a id="9845" href="Lecture5-notes.html#9459" data-type="(q ∙ p) ≡ (p ∙ r) → PathOver (λ x → x ≡ x) p q r" class="Function">PathOver-path-loop</a> <a id="9864" class="Symbol">(</a><a id="9865" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="9870" class="Symbol">_))))</a>
</pre>
Note that it is also possible to do this without funext by binding the
second input before doing the S1-rec on the first input (thanks Ulrik!):
<pre class="Agda"><a id="mult-nofunext"></a><a id="10029" href="Lecture5-notes.html#10029" data-type="S1 → S1 → S1" class="Function">mult-nofunext</a> <a id="10043" class="Symbol">:</a> <a id="10045" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a> <a id="10048" class="Symbol">→</a> <a id="10050" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a> <a id="10053" class="Symbol">→</a> <a id="10055" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a>
<a id="10058" href="Lecture5-notes.html#10029" data-type="S1 → S1 → S1" class="Function">mult-nofunext</a> <a id="10072" href="Lecture5-notes.html#10072" class="Bound">x</a> <a id="10074" href="Lecture5-notes.html#10074" class="Bound">y</a> <a id="10076" class="Symbol">=</a> <a id="10078" href="Lecture4-notes.html#5544" data-type="(x : X) → x ≡ x → S1 → X" class="Postulate">S1-rec</a> <a id="10085" href="Lecture5-notes.html#10074" class="Bound">y</a> <a id="10087" class="Symbol">(</a><a id="10088" href="Lecture5-notes.html#8624" data-type="(X : S1 → Set) (x : X base) →
PathOver X loop x x → (x₁ : S1) → X x₁" class="Postulate">S1-elim</a> <a id="10096" class="Symbol">(λ</a> <a id="10099" href="Lecture5-notes.html#10099" class="Bound">z</a> <a id="10101" class="Symbol">→</a> <a id="10103" href="Lecture5-notes.html#10099" class="Bound">z</a> <a id="10105" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="10107" href="Lecture5-notes.html#10099" class="Bound">z</a><a id="10108" class="Symbol">)</a> <a id="10110" href="Lecture4-notes.html#769" data-type="base ≡ base" class="Postulate">loop</a> <a id="10115" class="Symbol">(</a><a id="10116" href="Lecture5-notes.html#9459" data-type="(q ∙ p) ≡ (p ∙ r) → PathOver (λ x → x ≡ x) p q r" class="Function">PathOver-path-loop</a> <a id="10135" class="Symbol">(</a><a id="10136" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="10141" class="Symbol">_))</a> <a id="10145" href="Lecture5-notes.html#10074" class="Bound">y</a><a id="10146" class="Symbol">)</a> <a id="10148" href="Lecture5-notes.html#10072" class="Bound">x</a>
</pre>
<p>Above, we used the main part of function extensionality: a homotopy
induces a path between functions. The full form of the function
extensionality axiom (mentioned briefly in HoTT Lecture 5) is that
homotopies are equivalent to paths between functions, and in particular
that the map from paths to homotopies that you can define by path
induction is an equivalence.</p>
<pre class="Agda"><a id="app≡"></a><a id="10531" href="Lecture5-notes.html#10531" data-type="f ≡ g → f ∼ g" class="Function">app≡</a> <a id="10536" class="Symbol">:</a> <a id="10538" class="Symbol">{</a><a id="10539" href="Lecture5-notes.html#10539" class="Bound">l1</a> <a id="10542" href="Lecture5-notes.html#10542" class="Bound">l2</a> <a id="10545" class="Symbol">:</a> <a id="10547" href="Agda.Primitive.html#597" data-type="Set" class="Postulate">Level</a><a id="10552" class="Symbol">}</a> <a id="10554" class="Symbol">{</a><a id="10555" href="Lecture5-notes.html#10555" class="Bound">A</a> <a id="10557" class="Symbol">:</a> <a id="10559" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="10564" href="Lecture5-notes.html#10539" class="Bound">l1</a><a id="10566" class="Symbol">}</a> <a id="10568" class="Symbol">{</a><a id="10569" href="Lecture5-notes.html#10569" class="Bound">B</a> <a id="10571" class="Symbol">:</a> <a id="10573" href="Lecture5-notes.html#10555" class="Bound">A</a> <a id="10575" class="Symbol">→</a> <a id="10577" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="10582" href="Lecture5-notes.html#10542" class="Bound">l2</a><a id="10584" class="Symbol">}</a> <a id="10586" class="Symbol">{</a><a id="10587" href="Lecture5-notes.html#10587" class="Bound">f</a> <a id="10589" href="Lecture5-notes.html#10589" class="Bound">g</a> <a id="10591" class="Symbol">:</a> <a id="10593" class="Symbol">(</a><a id="10594" href="Lecture5-notes.html#10594" class="Bound">x</a> <a id="10596" class="Symbol">:</a> <a id="10598" href="Lecture5-notes.html#10555" class="Bound">A</a><a id="10599" class="Symbol">)</a> <a id="10601" class="Symbol">→</a> <a id="10603" href="Lecture5-notes.html#10569" class="Bound">B</a> <a id="10605" href="Lecture5-notes.html#10594" class="Bound">x</a><a id="10606" class="Symbol">}</a> <a id="10608" class="Symbol">→</a> <a id="10610" href="Lecture5-notes.html#10587" class="Bound">f</a> <a id="10612" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="10614" href="Lecture5-notes.html#10589" class="Bound">g</a> <a id="10616" class="Symbol">→</a> <a id="10618" href="Lecture5-notes.html#10587" class="Bound">f</a> <a id="10620" href="new-prelude.html#1372" data-type="((x : A) → B x) → ((x : A) → B x) → Set (l1 ⊔ l2)" class="Function Operator">∼</a> <a id="10622" href="Lecture5-notes.html#10589" class="Bound">g</a>
<a id="10624" href="Lecture5-notes.html#10531" data-type="f ≡ g → f ∼ g" class="Function">app≡</a> <a id="10629" href="Lecture5-notes.html#10629" class="Bound">p</a> <a id="10631" href="Lecture5-notes.html#10631" class="Bound">x</a> <a id="10633" class="Symbol">=</a> <a id="10635" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="10638" class="Symbol">(\</a> <a id="10641" href="Lecture5-notes.html#10641" class="Bound">f</a> <a id="10643" class="Symbol">→</a> <a id="10645" href="Lecture5-notes.html#10641" class="Bound">f</a> <a id="10647" href="Lecture5-notes.html#10631" class="Bound">x</a><a id="10648" class="Symbol">)</a> <a id="10650" href="Lecture5-notes.html#10629" class="Bound">p</a> 

<a id="10654" class="Keyword">postulate</a>
  <a id="λ≡βinv"></a><a id="10666" href="Lecture5-notes.html#10666" data-type="(h : f ∼ g) → app≡ (λ≡ h) ≡ h" class="Postulate">λ≡βinv</a> <a id="10673" class="Symbol">:</a> <a id="10675" class="Symbol">{</a><a id="10676" href="Lecture5-notes.html#10676" class="Bound">l1</a> <a id="10679" href="Lecture5-notes.html#10679" class="Bound">l2</a> <a id="10682" class="Symbol">:</a> <a id="10684" href="Agda.Primitive.html#597" data-type="Set" class="Postulate">Level</a><a id="10689" class="Symbol">}</a> <a id="10691" class="Symbol">{</a><a id="10692" href="Lecture5-notes.html#10692" class="Bound">A</a> <a id="10694" class="Symbol">:</a> <a id="10696" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="10701" href="Lecture5-notes.html#10676" class="Bound">l1</a><a id="10703" class="Symbol">}</a> <a id="10705" class="Symbol">{</a><a id="10706" href="Lecture5-notes.html#10706" class="Bound">B</a> <a id="10708" class="Symbol">:</a> <a id="10710" href="Lecture5-notes.html#10692" class="Bound">A</a> <a id="10712" class="Symbol">→</a> <a id="10714" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="10719" href="Lecture5-notes.html#10679" class="Bound">l2</a><a id="10721" class="Symbol">}</a> <a id="10723" class="Symbol">{</a><a id="10724" href="Lecture5-notes.html#10724" class="Bound">f</a> <a id="10726" href="Lecture5-notes.html#10726" class="Bound">g</a> <a id="10728" class="Symbol">:</a> <a id="10730" class="Symbol">(</a><a id="10731" href="Lecture5-notes.html#10731" class="Bound">x</a> <a id="10733" class="Symbol">:</a> <a id="10735" href="Lecture5-notes.html#10692" class="Bound">A</a><a id="10736" class="Symbol">)</a> <a id="10738" class="Symbol">→</a> <a id="10740" href="Lecture5-notes.html#10706" class="Bound">B</a> <a id="10742" href="Lecture5-notes.html#10731" class="Bound">x</a><a id="10743" class="Symbol">}</a> <a id="10745" class="Symbol">→</a> <a id="10747" class="Symbol">(</a><a id="10748" href="Lecture5-notes.html#10748" class="Bound">h</a> <a id="10750" class="Symbol">:</a> <a id="10752" href="Lecture5-notes.html#10724" class="Bound">f</a> <a id="10754" href="new-prelude.html#1372" data-type="((x : A) → B x) → ((x : A) → B x) → Set (l1 ⊔ l2)" class="Function Operator">∼</a> <a id="10756" href="Lecture5-notes.html#10726" class="Bound">g</a><a id="10757" class="Symbol">)</a> 
      <a id="10766" class="Symbol">→</a> <a id="10768" href="Lecture5-notes.html#10531" data-type="f ≡ g → f ∼ g" class="Function">app≡</a> <a id="10773" class="Symbol">(</a><a id="10774" href="new-prelude.html#2559" data-type="f ∼ g → f ≡ g" class="Postulate">λ≡</a> <a id="10777" href="Lecture5-notes.html#10748" class="Bound">h</a><a id="10778" class="Symbol">)</a> <a id="10780" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="10782" href="Lecture5-notes.html#10748" class="Bound">h</a>

<a id="10785" class="Comment">-- it&#39;s often more useful to have this as a homotopy</a>
<a id="λ≡β"></a><a id="10838" href="Lecture5-notes.html#10838" data-type="(h : f ∼ g) → app≡ (λ≡ h) ∼ h" class="Function">λ≡β</a> <a id="10842" class="Symbol">:</a> <a id="10844" class="Symbol">{</a><a id="10845" href="Lecture5-notes.html#10845" class="Bound">l1</a> <a id="10848" href="Lecture5-notes.html#10848" class="Bound">l2</a> <a id="10851" class="Symbol">:</a> <a id="10853" href="Agda.Primitive.html#597" data-type="Set" class="Postulate">Level</a><a id="10858" class="Symbol">}</a> <a id="10860" class="Symbol">{</a><a id="10861" href="Lecture5-notes.html#10861" class="Bound">A</a> <a id="10863" class="Symbol">:</a> <a id="10865" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="10870" href="Lecture5-notes.html#10845" class="Bound">l1</a><a id="10872" class="Symbol">}</a> <a id="10874" class="Symbol">{</a><a id="10875" href="Lecture5-notes.html#10875" class="Bound">B</a> <a id="10877" class="Symbol">:</a> <a id="10879" href="Lecture5-notes.html#10861" class="Bound">A</a> <a id="10881" class="Symbol">→</a> <a id="10883" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="10888" href="Lecture5-notes.html#10848" class="Bound">l2</a><a id="10890" class="Symbol">}</a> <a id="10892" class="Symbol">{</a><a id="10893" href="Lecture5-notes.html#10893" class="Bound">f</a> <a id="10895" href="Lecture5-notes.html#10895" class="Bound">g</a> <a id="10897" class="Symbol">:</a> <a id="10899" class="Symbol">(</a><a id="10900" href="Lecture5-notes.html#10900" class="Bound">x</a> <a id="10902" class="Symbol">:</a> <a id="10904" href="Lecture5-notes.html#10861" class="Bound">A</a><a id="10905" class="Symbol">)</a> <a id="10907" class="Symbol">→</a> <a id="10909" href="Lecture5-notes.html#10875" class="Bound">B</a> <a id="10911" href="Lecture5-notes.html#10900" class="Bound">x</a><a id="10912" class="Symbol">}</a> <a id="10914" class="Symbol">→</a> <a id="10916" class="Symbol">(</a><a id="10917" href="Lecture5-notes.html#10917" class="Bound">h</a> <a id="10919" class="Symbol">:</a> <a id="10921" href="Lecture5-notes.html#10893" class="Bound">f</a> <a id="10923" href="new-prelude.html#1372" data-type="((x : A) → B x) → ((x : A) → B x) → Set (l1 ⊔ l2)" class="Function Operator">∼</a> <a id="10925" href="Lecture5-notes.html#10895" class="Bound">g</a><a id="10926" class="Symbol">)</a> 
      <a id="10935" class="Symbol">→</a> <a id="10937" href="Lecture5-notes.html#10531" data-type="f ≡ g → f ∼ g" class="Function">app≡</a> <a id="10942" class="Symbol">(</a><a id="10943" href="new-prelude.html#2559" data-type="f ∼ g → f ≡ g" class="Postulate">λ≡</a> <a id="10946" href="Lecture5-notes.html#10917" class="Bound">h</a><a id="10947" class="Symbol">)</a> <a id="10949" href="new-prelude.html#1372" data-type="((x : A) → B x) → ((x : A) → B x) → Set (l1 ⊔ l2)" class="Function Operator">∼</a> <a id="10951" href="Lecture5-notes.html#10917" class="Bound">h</a>
<a id="10953" href="Lecture5-notes.html#10838" data-type="(h : f ∼ g) → app≡ (λ≡ h) ∼ h" class="Function">λ≡β</a> <a id="10957" href="Lecture5-notes.html#10957" class="Bound">h</a> <a id="10959" class="Symbol">=</a> <a id="10961" href="Lecture5-notes.html#10531" data-type="f ≡ g → f ∼ g" class="Function">app≡</a> <a id="10966" class="Symbol">(</a><a id="10967" href="Lecture5-notes.html#10666" data-type="(h : f ∼ g) → app≡ (λ≡ h) ≡ h" class="Postulate">λ≡βinv</a> <a id="10974" href="Lecture5-notes.html#10957" class="Bound">h</a><a id="10975" class="Symbol">)</a>

<a id="full-funext"></a><a id="10978" href="Lecture5-notes.html#10978" data-type="is-equiv app≡" class="Function">full-funext</a> <a id="10990" class="Symbol">:</a> <a id="10992" class="Symbol">{</a><a id="10993" href="Lecture5-notes.html#10993" class="Bound">l1</a> <a id="10996" href="Lecture5-notes.html#10996" class="Bound">l2</a> <a id="10999" class="Symbol">:</a> <a id="11001" href="Agda.Primitive.html#597" data-type="Set" class="Postulate">Level</a><a id="11006" class="Symbol">}</a> <a id="11008" class="Symbol">{</a><a id="11009" href="Lecture5-notes.html#11009" class="Bound">A</a> <a id="11011" class="Symbol">:</a> <a id="11013" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="11018" href="Lecture5-notes.html#10993" class="Bound">l1</a><a id="11020" class="Symbol">}</a> <a id="11022" class="Symbol">{</a><a id="11023" href="Lecture5-notes.html#11023" class="Bound">B</a> <a id="11025" class="Symbol">:</a> <a id="11027" href="Lecture5-notes.html#11009" class="Bound">A</a> <a id="11029" class="Symbol">→</a> <a id="11031" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="11036" href="Lecture5-notes.html#10996" class="Bound">l2</a><a id="11038" class="Symbol">}</a> <a id="11040" class="Symbol">{</a><a id="11041" href="Lecture5-notes.html#11041" class="Bound">f</a> <a id="11043" href="Lecture5-notes.html#11043" class="Bound">g</a> <a id="11045" class="Symbol">:</a> <a id="11047" class="Symbol">(</a><a id="11048" href="Lecture5-notes.html#11048" class="Bound">x</a> <a id="11050" class="Symbol">:</a> <a id="11052" href="Lecture5-notes.html#11009" class="Bound">A</a><a id="11053" class="Symbol">)</a> <a id="11055" class="Symbol">→</a> <a id="11057" href="Lecture5-notes.html#11023" class="Bound">B</a> <a id="11059" href="Lecture5-notes.html#11048" class="Bound">x</a><a id="11060" class="Symbol">}</a>
            <a id="11074" class="Symbol">→</a> <a id="11076" href="Lecture5-notes.html#699" data-type="(f : A → B) → Set (l1 ⊔ l2)" class="Record">is-equiv</a> <a id="11085" class="Symbol">{</a><a id="11086" class="Argument">A</a> <a id="11088" class="Symbol">=</a> <a id="11090" href="Lecture5-notes.html#11041" class="Bound">f</a> <a id="11092" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="11094" href="Lecture5-notes.html#11043" class="Bound">g</a><a id="11095" class="Symbol">}</a> <a id="11097" class="Symbol">{</a><a id="11098" class="Argument">B</a> <a id="11100" class="Symbol">=</a> <a id="11102" href="Lecture5-notes.html#11041" class="Bound">f</a> <a id="11104" href="new-prelude.html#1372" data-type="((x : A) → B x) → ((x : A) → B x) → Set (l1 ⊔ l2)" class="Function Operator">∼</a> <a id="11106" href="Lecture5-notes.html#11043" class="Bound">g</a><a id="11107" class="Symbol">}</a> <a id="11109" href="Lecture5-notes.html#10531" data-type="f ≡ g → f ∼ g" class="Function">app≡</a>
<a id="11114" href="Lecture5-notes.html#10978" data-type="is-equiv app≡" class="Function">full-funext</a> <a id="11126" class="Symbol">=</a> <a id="11128" href="Lecture5-notes.html#801" data-type="(post-inverse : B → A) (is-post-inverse : (post-inverse ∘ f) ∼ id)
(pre-inverse : B → A) (is-pre-inverse : (f ∘ pre-inverse) ∼ id) →
is-equiv f" class="InductiveConstructor">Inverse</a> <a id="11136" href="Lecture5-notes.html#11176" data-type="f ∼ g → f ≡ g" class="Postulate">λ≡&#39;</a> <a id="11140" href="Lecture5-notes.html#11188" data-type="(λ≡&#39; ∘ app≡) ∼ id" class="Postulate">λ≡η</a> <a id="11144" href="new-prelude.html#2559" data-type="f ∼ g → f ≡ g" class="Postulate">λ≡</a> <a id="11147" href="Lecture5-notes.html#10666" data-type="(h : f ∼ g) → app≡ (λ≡ h) ≡ h" class="Postulate">λ≡βinv</a> <a id="11154" class="Keyword">where</a>
  <a id="11162" class="Keyword">postulate</a>
    <a id="11176" href="Lecture5-notes.html#11176" data-type="f ∼ g → f ≡ g" class="Postulate">λ≡&#39;</a> <a id="11180" class="Symbol">:</a> <a id="11182" class="Symbol">_</a>
    <a id="11188" href="Lecture5-notes.html#11188" data-type="(λ≡&#39; ∘ app≡) ∼ id" class="Postulate">λ≡η</a> <a id="11192" class="Symbol">:</a> <a id="11194" class="Symbol">_</a>
</pre>

  </article>
</div>
</main>
</body>
<style>

:root {
  --text-bg: #fff;
  --text-fg: #222;
  --shadow: #000;
  --primary: #0054F4;
  --secondary: #9C1BD6;
  --modal-bg: #ccccccaa;
  --warning-bg: #fef08a;
  --code-bg: var(--text-bg);
  --code-fg: var(--text-fg);
  --code-keyword: #BB3B13;
  --code-string:  #d52753;
  --code-number:  #8A1060;
  --code-module:  #8A1060;
  --code-field:   #9C1BD6;
  --code-constructor: #207B1D;
  --code-highlight: #F5DEB3;
  --search-selected: #e2e8f0;
  --details-summary: #b2ebf2;
  --details-open:    #80deea;
  --depgraph-edge: #eee;
  --blockquote-bg: #d8b4fe; }

.diagram-dark {
  display: none !important; }

@media (prefers-color-scheme: dark) {
  :root {
    --text-bg: #282C34;
    --text-fg: #bfbfbf;
    --shadow: #475569;
    --primary: #61AFEF;
    --secondary: #C878DD;
    --modal-bg: #282C34aa;
    --warning-bg: #991b1b;
    --code-keyword:     #E5C07B;
    --code-string:      #E06C75;
    --code-number:      #98C379;
    --code-module:      #56B6C2;
    --code-field:       #C878DD;
    --code-constructor: #98C379;
    --code-highlight: #ef444499;
    --search-selected: #474e5e;
    --details-summary: #5b21b6;
    --details-open:    #4c1d95;
    --depgraph-edge: #474e5e;
    --blockquote-bg: #475569; }
  div.warning {
    --shadow: #7f1d1d
  ; }
  input {
    background-color: #334155;
    border: 1px solid #475569;
    color: var(--text-fg); }
  body {
    scrollbar-color: #3b4454 #2b2e33; }
  .diagram-dark {
    display: block !important; }
  .diagram-light {
    display: none !important; } }

table {
  margin: auto;
  border-collapse: collapse; }
  table td, table th {
    text-align: center;
    padding: 0px 1em 0px 1em;
    border: 1px solid black; }
  table th {
    border-bottom: 2px solid black; }
  table td {
    white-space: nowrap; }

html { max-width: 100%; }

body {
  font-family: "Inria Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  width: 100%;
  font-size: var(--font-size);
  overflow-x: clip;
  background-color: var(--text-bg);
  color: var(--text-fg);
}

div#post-toc-container { max-width: 120ch; margin: auto; }

article a[href], div#return > a[href], div#top > a[href], aside#toc > div#toc-container ul a[href] {
  color: var(--primary);
  text-decoration: none; }
  article a[href]:hover, div#return > a[href]:hover, div#top > a[href]:hover, aside#toc > div#toc-container ul a[href]:hover {
    text-decoration: 2px currentColor underline !important; }
  article a[href]:visited, div#return > a[href]:visited, div#top > a[href]:visited, aside#toc > div#toc-container ul a[href]:visited {
    color: var(--secondary); }

/* Aspects. */
.Agda {
  /* NameKinds. */
  /* OtherAspects. */
  /* Standard attributes. */
  font-family: 'iosevka', 'Iosevka', 'Fantasque Sans Mono', 'Roboto Mono', monospace;
  font-weight: 400; }
  .Agda .Comment {
    color: var(--code-fg);
    font-style: italic; }
  .Agda .Background {
    background-color: var(--code-bg); }
  .Agda .Markup {
    color: var(--code-fg); }
  .Agda .Keyword {
    color: var(--code-keyword); }
  .Agda .String {
    color: var(--code-string); }
  .Agda .Number {
    color: var(--code-number); }
  .Agda .Symbol {
    color: var(--code-fg); }
  .Agda .PrimitiveType {
    color: var(--primary); }
  .Agda .Pragma {
    color: var(--code-fg); }
  .Agda .Bound {
    color: var(--code-fg) !important; }
  .Agda .Generalizable {
    color: var(--code-fg) !important; }
  .Agda .InductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .CoinductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .Datatype {
    color: var(--primary) !important; }
  .Agda .Field {
    color: var(--code-field) !important; }
  .Agda .Function {
    color: var(--primary) !important; }
  .Agda .Module {
    color: var(--code-module) !important; }
  .Agda .Postulate {
    color: var(--primary) !important; }
  .Agda .Primitive {
    color: var(--primary) !important; }
  .Agda .Record {
    color: var(--primary) !important; }
  .Agda .UnsolvedMeta {
    color: var(--code-fg);
    background: yellow; }
  .Agda .UnsolvedConstraint {
    color: var(--code-fg);
    background: yellow; }
  .Agda .TerminationProblem {
    color: var(--code-fg);
    background: #FFA07A; }
  .Agda .IncompletePattern {
    color: var(--code-fg);
    background: #F5DEB3; }
  .Agda .Error {
    color: red;
    text-decoration: underline; }
  .Agda .TypeChecks {
    color: var(--code-fg);
    background: #ADD8E6; }
  .Agda .ShadowingInTelescope {
    color: var(--code-fg);
    background: #808080; }
  .Agda .Deadcode {
    color: var(--code-keyword);
    font-weight: bold; }
  .Agda a {
    text-decoration: none; }
  .Agda a[href]:hover {
    text-decoration: 2px var(--primary) underline; }
  .Agda a[href]:target {
    animation: highlight 2.5s; }
  body.text-page .Agda {
    font-size: var(--code-font-size); }

pre.Agda, div.sourceCode, pre {
  border-radius: 0;
  box-shadow: none;
  overflow-y: clip;
  margin: 0;
  padding: 1em;
  padding-top: 0.25em;
  padding-bottom: 0.25em;
  background-color: var(--code-bg);
  color: var(--code-fg);
  font-size: var(--code-font-size);
  max-width: 100%;
  overflow-x: auto;
}
</style>
</html>
